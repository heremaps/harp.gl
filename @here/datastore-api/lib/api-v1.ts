/*
 * Copyright (C) 2017-2018 HERE Global B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/**
 * DataStore API Specification
 *
 * The DataStore API allows to query and download data from versioned catalogs. It supports both
 * consistent views on specific versions, and the retrieval of changes between versions. The
 * DataStore API is a REST API that can be accessed using HTTPS. Documentation of old and DEPRECATED
 * v0.1 API can be found here: http://spec-v01.datastore.api.here.com/.
 *
 * OpenAPI spec version: 2.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { RequestBuilder, RequestOptions, UrlBuilder } from "./RequestBuilder";

/**
 * The `AdminConfiguration` contains version-independent information about the catalog.
 */
export interface AdminConfiguration {
    /**
     * A list of properties of the catalog. All properties need unique names; multiple properties
     * with the same name are not supported. There is a maximum of 25 properties per catalog.
     */
    properties: Property[];
    /**
     * The layers property contains version-independent information about the layers. Some parts of
     * this configuration may change over time, for example, the properties of a layer. In this
     * case, the detailed handling of changes is described with the parameter. New layer can be
     * added over the time but no layer can be removed. The maximum number of layers in a catalog is
     * 250.
     */
    layers: Layer[];
    /**
     * List of catalog HRNs that together hold the content of this catalog. The maximum number of
     * entries is 50.
     */
    dataCatalogs?: string[];
    /**
     * Version of this configuration.
     */
    version?: number;
}

export interface CandidatePartition {
    /**
     * Name of the partition.
     */
    partition: string;
    /**
     * Name of the layer. Content of this field must refer to a valid layer already configured in
     * the catalog configuration. Allowed are only: a-z, A-Z, 0-9, '_' and '-' characters. The
     * partition layer cannot be empty. Maximum length is 50 characters.
     */
    layer: string;
    /**
     * The checksum must be calculated the same way as the checksum provided during commit in the
     * `PartitionMetadataCommit` objects.
     */
    checksum: string;
}

export interface CandidatePartitions {
    /**
     * List of partitions that should be part of the new version. This may include changed and
     * unchanged partitions. This list must be sorted ascending; first by layer name and then by
     * partition name for partitions inside the same layer.
     */
    partitions: CandidatePartition[];
}

/**
 * The `CatalogConfiguration` contains version-independent information about the catalog.
 */
export interface CatalogConfiguration {
    /**
     * A list of properties of the catalog. All properties need unique names; multiple properties
     * with the same name are not supported. There is a maximum of 25 properties per catalog.
     */
    properties?: Property[];
    /**
     * The layers property contains version-independent information about the layers. Some parts of
     * this configuration may change over time, for example, the properties of a layer. In this
     * case, the detailed handling of changes is described with the parameter. New layer can be
     * added over the time but no layer can be removed. The maximum number of layers in a catalog is
     * 250.
     */
    layers: Layer[];
    /**
     * List of catalog HRNs that together hold the content of this catalog. The maximum number of
     * entries is 50.
     */
    dataCatalogs?: string[];
    /**
     * Version of this configuration.
     */
    version?: number;
}

export interface CatalogInfo {
    /**
     * A HERE Resource Name.
     */
    hrn: string;
    /**
     * Name of the project publishing to the catalog.
     */
    project?: string;
    /**
     * Contact should contain a list of comma-separated email addresses where the responsible
     * persons for the catalog can be contacted.
     */
    contact?: string;
    /**
     * Name of the organization or department publishing to the catalog.
     */
    department?: string;
    /**
     * Comment that helps understand the content and purpose of the catalog for a human reader.
     */
    comment?: string;
    /**
     * Link to documentation for the project publishing to the catalog.
     */
    documentation?: string;
    /**
     * Information if the catalog data can be read by everyone who uses can access the catalog. If
     * `false`, the catalog access is restricted to some list of clients.
     */
    isPublic?: boolean;
}

export interface CatalogList {
    /**
     * List of catalog names.
     */
    catalogs: string[];
}

export interface ChangedPartition {
    /**
     * Name of the partition.
     */
    partition: string;
    /**
     * Name of the layer.
     */
    layer: string;
    /**
     * The deleted parameter is optional and used only by comparison with deletes detection.
     */
    deleted?: boolean;
}

export interface ChangedPartitions {
    /**
     * List of changed or deleted partitions.
     */
    partitions: ChangedPartition[];
}

export interface ChangesetQuery {
    /**
     * Layer names to use for filtering. When absent, all layers are considered.
     */
    layers?: string[];
}

export interface ChangesetStatistics {
    /**
     * List of ChangesetStatistic objects for queried catalogs.
     */
    layers: LayerChangesetStatistic[];
}

export interface ChangesetStatisticsToken {
    /**
     * String containing the token.
     */
    token: string;
}

export interface CommitPartition {
    /**
     * Name of the partition. If the partitioning scheme is 'quadtree' (deprecated), this is the id
     * of the tile composed of the digits 0-3 or the root quad described by the single character
     * dash ('-'). If the partitioning scheme is 'heretile', allowed characters are 0-9. If the
     * partitioning scheme is 'generic' allowed characters for the partition name are: a-z, A-Z,
     * 0-9, '_', '-', '.', and '/'. The maximum length of a partition name is 500 characters.
     */
    partition: string;
    /**
     * Name of the layer. Content of this field must refer to a valid layer already configured in
     * the catalog configuration. Allowed are only: a-z, A-Z, 0-9, '_' and '-' characters. The
     * partition layer cannot be empty. Maximum length is 50 characters.
     */
    layer: string;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layerâ€™s `dataUrl`. The
     * combination of `dataUrl` + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly, the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle: string;
    /**
     * The checksum parameter is optional. It should be set to the sha1 checksum of the data content
     * if the data comparison needs to work for this catalog. This parameter should not be set for
     * deleted partitions. The maximum length of `checksum` field is 128 characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the partition data pointed to by the `dataHandle` value in
     * bytes. It is the uncompressed size of the partition data if it was populated by
     * datastore-client.
     */
    dataSize?: number;
    /**
     * Optional value for the size of the compressed partition data in bytes. It is the compressed
     * size of the data when using `S3Blobstore` in the datastore-client with compression enabled to
     * commit to DataStore. It is only included if the `compressedDataSize` field was requested in
     * the API call, and if a `compressedDataSize` was provided during commit of the partition.
     */
    compressedDataSize?: number;
}

export interface CommitPartitions {
    /**
     * List of dependencies that were used to generate the data of this version. If no dependencies
     * exist for example, for data sources, an empty list should be passed.
     */
    dependencies: VersionDependency[];
    /**
     * This set of changed or deleted partitions must be sorted. The sorting must be ascending;
     * first by layer name and then by partition name for partitions inside the same layer.
     */
    partitions: CommitPartition[];
}

/**
 * The `Configuration` contains version-independent information about the catalog.
 */
export interface Configuration {
    /**
     * The layers property contains version-independent information about the layers. Some parts of
     * this configuration may change over time, for example, the properties of a layer. In this
     * case, the detailed handling of changes is described with the parameter. New layer can be
     * added over the time but no layer can be removed. The maximum number of layers in a catalog is
     * 250.
     */
    layers: Layer[];
    /**
     * List of catalog HRNs that together hold the content of this catalog. The maximum number of
     * entries is 50.
     */
    dataCatalogs?: string[];
}

export interface DeletablePartitions {
    /**
     * List of deletable partitions.
     */
    partitions: Partition[];
    /**
     * New minimum version at which none of the returned partitions will be referenced anymore.
     */
    newMinimumVersion: number;
    /**
     * Flag to indicate if more versions are already retired. If set to `true`,
     * `deletablePartitions` should be called again after deleting all versions up to (but
     * excluding) the returned `newMinimumVersion`.
     */
    last: boolean;
}

export interface Index {
    /**
     * Result of the index resource call. For each tile that contains data in the requested quadkey,
     * one element with the respective sub-quad data is contained in the array.
     */
    subQuads: SubQuad[];
    /**
     * Result of the index resource call. For each parent tile, one element with the respective
     * parent-quad data is contained in the array.
     */
    parentQuads: ParentQuad[];
}

/**
 * Defines the Statistics of the Index store for one catalog.
 */
export interface IndexStatistics {
    /**
     * Name of the catalog.
     */
    catalog: string;
    /**
     * Approximate total number of partitions committed to this catalog, including every change of a
     * partition.
     */
    committedPartitionCount: number;
    /**
     * Approximate total size in bytes representing all partition metadata in this catalog.
     */
    committedPartitionSize: number;
    /**
     * Number of versions from this catalog that are in the index.
     */
    versionCount: number;
    /**
     * Approximate number of keys in the index. Every present unique (partition, layer) tuple is one
     * key, independent of the number of versions it has.
     */
    keyCount: number;
}

export interface IndexStatisticsList {
    /**
     * List of IndexStatistics entries.
     */
    indexStatistics: IndexStatistics[];
}

export interface LatestVersion {
    /**
     * The latest version available in the catalog.
     */
    version: number;
}

/**
 * Defines the meta data of a layer.
 */
export interface Layer {
    /**
     * Name of the layer. Allowed characters for the layer name are: a-z, A-Z, 0-9, '_', '-' and
     * '.'. Maximum length of a layer name is 50 characters.
     */
    name: string;
    /**
     * The partitioning scheme of this layer. Either 'generic', 'heretile' or 'quadtree'
     * (deprecated). 'generic' is for layers that do not have any special relation between the
     * partition names. The other partitioning schemes are defined in more detail in the User Guide.
     */
    partitioning: LayerPartitioningEnum;
    /**
     * The base URL for requesting data. This is a fully specified URL including the protocol (for
     * example: 'http', 'https', 'file', 'ftp'). After appending a `dataHandle` field, content of
     * the requested partition client should be able to obtain the partition content. If this
     * field is not present or empty, the partition `dataHandle` must contain a fully qualified URL.
     * The value of this parameter may change over the time. Since changes in this field potentially
     * affect all effective URLs in a given layer for all catalog versions, any change must be done
     * with caution. The returned value is guaranteed to work for 24h, clients should renew it after
     * that period.
     */
    dataUrl?: string;
    /**
     * A list of additional properties of the layer. These are not evaluated by DataStore itself.
     * All properties need unique names; multiple properties with the same name are not supported.
     * There is a maximum of 20 properties per layer.
     */
    layerProperties?: Property[];
}

export type LayerPartitioningEnum = "generic" | "quadtree" | "heretile";
/**
 * Defines the ChangesetStatistics object for one layer.
 */
export interface LayerChangesetStatistic {
    /**
     * Name of the layer.
     */
    layer: string;
    /**
     * Current state of gathering statistics for the layer. Possible values: processing, completed
     * or failed
     */
    state: LayerChangesetStatisticStateEnum;
    /**
     * Number of partitions in the changeset statistics
     */
    partitionCount: number;
}

export type LayerChangesetStatisticStateEnum = "processing" | "completed" | "failed";
export interface LayerVersion {
    /**
     * Name of the layer.
     */
    layer: string;
    /**
     * Version of the catalog when the layer was last changed. Only versions before and including
     * the requested catalog version are evaluated. Note: version can refer to already retired and
     * thus inaccessible version.
     */
    version: number;
}

export interface LayerVersions {
    /**
     * Version of this catalog.
     */
    version: number;
    /**
     * Layers with their latest version at which data was committed, layers without committed
     * partitions will be omitted.
     */
    layerVersions: LayerVersion[];
}

export interface MultipartCommitRequest {
    /**
     * List of multipart commit dependencies.
     */
    dependencies: VersionDependency[];
}

export interface MultipartPart {
    /**
     * Id of the part.
     */
    partId: string;
    /**
     * md5 checksum of the uploaded content body of the part.
     */
    md5: string;
}

export interface MultipartParts {
    /**
     * List of parts that shall be committed to the new version.
     */
    parts: MultipartPart[];
}

export interface MultipartStatus {
    /**
     * Token retrieved from a call to /publish/multipart/start.
     */
    token: string;
    /**
     * Status of a multipart upload.
     */
    status: MultipartStatusStatusEnum;
    /**
     * Number of partitions that have already been parsed. This value will be the total number of
     * partitions contained in the commit when it has reached the completed state.
     */
    parsingProgress: number;
    /**
     * This indicates progress on optional processing that may happen after parsingProgress has
     * finished. If neither parsingProgress nor processingProgress have changed for more than 5
     * minutes, the commit is probably in an error state and should be aborted and retried.
     */
    processingProgress: number;
    /**
     * For failed multipart uploads, an error message may be included here.
     */
    message?: string;
}

export type MultipartStatusStatusEnum =
    | "started"
    | "processing"
    | "completed"
    | "failed"
    | "aborted";
export interface MultipartStatuses {
    /**
     * List of multipart status for all tokens active on this catalog.
     */
    statuses: MultipartStatus[];
}

export interface MultipartToken {
    /**
     * String containing the token.
     */
    token: string;
}

export interface MultipartUrl {
    /**
     * Id of the part. Has to be returned together with an md5 checksum of the uploaded data when
     * committing the part.
     */
    partId: string;
    /**
     * URL where a JSON serialized instance of CommitPartitions should be PUT. A `Content-Type`
     * header with the value 'application/json' has to be set on the PUT request. This URL is only
     * valid for around the next 30 minutes, and expiration time in UTC can be checked in the
     * expiration field.
     */
    url: string;
    /**
     * Content type used for uploading the part. Allowed values are `application/json`. Uploading
     * may fail if the `Content-Type` header of the PUT command does not match this value.
     */
    contentType: string;
    /**
     * Timestamp in milliseconds, in the UTC timezone when the URL will expire. Timestamp will be
     * set at requested `partUrl` time plus 30 minutes.
     */
    expiration: number;
}

/**
 * Defines the meta data for a parent tile in the index resource.
 */
export interface ParentQuad {
    /**
     * The id of the tile.
     */
    partition: string;
    /**
     * Version of the catalog when this partition was first published.
     */
    version: number;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layerâ€™s `dataUrl`. The
     * combination of `dataUrl` + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly, the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle: string;
    /**
     * The checksum field is optional. It is only included if a checksum was requested in the API
     * call (using 'additionalFields' query parameter) and if a checksum was provided during commit
     * of the partition. It should be set to the sha1 checksum of the data content if the data
     * comparison needs to work for this catalog. The maximum length of checksum field is 128
     * characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the partition data in bytes. It is the uncompressed size of
     * the data when using `S3Blobstore` in the datastore-client with compression enabled or
     * disabled to commit to DataStore. It is only included if the `dataSize` field was requested in
     * the API call, and if a `dataSize` was provided during commit of the partition.
     */
    dataSize?: number;
    /**
     * Optional value for the size of the compressed partition data in bytes. It is the compressed
     * size of the data when using `S3Blobstore` in the datastore-client with compression enabled to
     * commit to DataStore. It is only included if the `compressedDataSize` field was requested in
     * the API call, and if a `compressedDataSize` was provided during commit of the partition.
     */
    compressedDataSize?: number;
}

/**
 * Metadata for one partition of a layer.
 */
export interface Partition {
    /**
     * Name of the partition. If the partition is using a tiling partitioning scheme, this is the id
     *  of the tile. The name cannot be empty. Maximum length of this field is 500 characters.
     */
    partition: string;
    /**
     * Name of the layer. Content of this field must refer to a valid layer already configured in
     * the catalog configuration. Allowed are only: a-z, A-Z, 0-9, '_' and '-' characters. The
     * partition layer cannot be empty. Maximum length is 50 characters.
     */
    layer: string;
    /**
     * For active partitions, the version of the catalog when this partition was last changed. For
     * deleted partitions, either the version when it was deleted or the version of the first
     * snapshot after it was deleted.
     */
    version: number;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layerâ€™s `dataUrl`. The
     * combination of `dataUrl` + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly, the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle?: string;
    /**
     * The checksum field is optional. It is only included if the checksum was requested in the API
     * call (using 'additionalFields' query parameter) and if a checksum was provided during commit
     * of the partition. It should be set to the sha1 checksum of the data content if the data
     * comparison needs to work for this catalog. The maximum length of checksum field is 128
     * characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the partition data in bytes. It is the uncompressed size of
     * the data when using `S3Blobstore` in the datastore-client with compression enabled or
     * disabled to commit to DataStore. It is only included if the `dataSize` field was requested in
     * the API call, and if a `dataSize` was provided during commit of the partition.
     */
    dataSize?: number;
    /**
     * Optional value for the size of the compressed partition data in bytes. It is the compressed
     * size of the data when using `S3Blobstore` in the datastore-client with compression enabled to
     * commit to DataStore. It is only included if the `compressedDataSize` field was requested in
     * the API call, and if a `compressedDataSize` was provided during commit of the partition.
     */
    compressedDataSize?: number;
}

export interface PartitionQuery {
    /**
     * Requested version.
     */
    version: number;
    /**
     * List of requested layers. If this parameter is not supplied, layers must be correctly
     * configured in the catalog configuration and all layers are returned.
     */
    layers?: string[];
    /**
     * List of requested partitions. If this parameter is not supplied, all partitions of the
     * selected layers are returned.
     */
    partitions?: string[];
}

export interface Partitions {
    /**
     * Queried list of partition meta data.
     */
    partitions: Partition[];
}

/**
 * A generic name value property object.
 */
export interface Property {
    /**
     * Name of the property. Allowed characters for the property name are: a-z, A-Z, 0-9, '_', '-'
     * and '.'. Maximum length of a property name is 50 characters. Empty property names are not
     * allowed.
     */
    name: string;
    /**
     * Value of the property. Maximum length of the value is 255 characters in UTF-8. Empty strings
     * as value are not allowed.
     */
    value: string;
}

/**
 * Defines the meta data for a tile in the index resource.
 */
export interface SubQuad {
    /**
     * Variable length string defining the child of the passed in the quadkey tile. Depending on the
     * partitioning scheme of the layer, either a 'quadtree' (deprecated) or a 'heretile' formatted
     * id from the sub quad will be returned. When the quadkey is referenced in the response (for
     * example, when depth is 0), `subQuadKey` is an empty string for 'quadtree' partitioning, and
     * '1' for 'heretile' partitioning.
     */
    subQuadKey: string;
    /**
     * Version of the catalog when this partition was first published.
     */
    version: number;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layerâ€™s `dataUrl`. The
     * combination of `dataUrl` + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly, the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle: string;
    /**
     * The checksum field is optional. It is only included if the checksum was requested in the API
     * call (using 'additionalFields' query parameter) and if a checksum was provided during commit
     * of the partition. It should be set to the sha1 checksum of the data content if the data
     * comparison needs to work for this catalog. The maximum length of checksum field is 128
     * characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the partition data in bytes. It is the uncompressed size of
     * the data when using `S3Blobstore` in the datastore-client with compression enabled or
     * disabled to commit to DataStore. It is only included if the `dataSize` field were requested
     * in the API call, and if a `dataSize` was provided during commit of the partition.
     */
    dataSize?: number;
    /**
     * Optional value for the size of the compressed partition data in bytes. It is the compressed
     * size of the data when using `S3Blobstore` in the datastore-client with compression enabled to
     * commit to DataStore. It is only included if the `compressedDataSize` field was requested in
     * the API call, and if a `compressedDataSize` was provided during commit of the partition.
     */
    compressedDataSize?: number;
}

export interface VersionDependency {
    /**
     * Name of a catalog that was used at any time to generate data for this version of this
     * catalog. Allowed characters for the catalog name are: a-z, A-Z, 0-9, '_', '-' and '.'. Either
     * `hrn` or `name` must be set when committing a `VersionDependency`. Both will be set when
     * reading a `VersionDependency`.
     */
    name?: string;
    /**
     * HRN of the catalog that was used at any time to generate data for this version of this
     * catalog. Either `hrn` or `name` must be set when committing a `VersionDependency`. Both will
     * be set when reading a `VersionDependency`.
     */
    hrn?: string;
    /**
     * Version of the catalog that was used as a dependency.
     */
    version: number;
    /**
     * If this value is set to `true`, this dependency is an indirect dependency. This means that
     * data from this catalog was not used by the filter processing the current version, it was only
     * used by other upstream filters to generate the input data for this filter.
     */
    indirect?: boolean;
}

export interface VersionInfo {
    /**
     * Version of this catalog.
     */
    version: number;
    /**
     * Timestamp from generation of this version (in ms since 01/01/1970 00:00 UTC).
     */
    timestamp: number;
    /**
     * Minimum duration in seconds (relative to the time of the response) that this version will be
     * kept available in Data Store. After expiry of the TTL, meta data as well as referenced
     * dataHandles may no longer be available. The client can recheck the version information at any
     * time to find out if the time to live has been extended.
     */
    timeToLive: number;
    /**
     * List of catalogs and versions that were used as a dependency to generate this version.
     */
    dependencies: VersionDependency[];
    /**
     * The number of partitions changed in this commit for this version, counted by layer.
     */
    partitionCounts?: { [key: string]: number };
}

export interface VersionInfos {
    /**
     * Information about the requested versions.
     */
    versions: VersionInfo[];
}

/**
 * Deletes a catalog including its configuration.
 *
 * @summary Deletes a catalog.
 * @param catalog The name of the catalog that should be deleted.
 */
export function deleteConfiguration(
    builder: RequestBuilder,
    params: { catalog: string }
): Promise<any> {
    const baseUrl = "/v2/admin/catalog/{catalog}".replace(
        "{catalog}",
        UrlBuilder.toString(params.catalog)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Get configuration of a catalog.
 *
 * @summary Returns configuration of a catalog.
 * @param catalog The id of the catalog that should be returned.
 */
export function getCatalogConfiguration(
    builder: RequestBuilder,
    params: { catalog: string }
): Promise<AdminConfiguration> {
    const baseUrl = "/v2/admin/catalog/{catalog}".replace(
        "{catalog}",
        UrlBuilder.toString(params.catalog)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<AdminConfiguration>(urlBuilder, options);
}

/**
 * Get a list of catalogs available from metadata store.
 *
 * @summary Returns list of catalogs available from metadata store.
 */
export function getCatalogs(builder: RequestBuilder): Promise<CatalogList> {
    const baseUrl = "/v2/admin/catalogs";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<CatalogList>(urlBuilder, options);
}

/**
 * Returns statistics about the index storage use for each catalog.
 *
 * @summary Get index statistics for all catalogs.
 */
export function getIndexStatistics(builder: RequestBuilder): Promise<IndexStatisticsList> {
    const baseUrl = "/v2/admin/indexStatistics";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<IndexStatisticsList>(urlBuilder, options);
}

/**
 * Puts configuration of a catalog. If the catalog does not exist it will be created.
 *
 * @summary Writes configuration of a catalog.
 * @param catalog The id of the catalog that should be created. Allowed characters for the catalog
 * name are: a-z, A-Z, 0-9, '-'. The use of '_' is currently also possible, but will
 * not allow addressing the catalog in a virtual host mode.
 * @param configuration The configuration of the catalog. If the catalog already exists, it will
 * overwrite any previous existing configuration. If body contains the catalog version property it
 * should match the current configuration version plus one. If the version is not provided DataStore
 * will automatically use next version. Client should provide explicit version as it will work as
 * optimistic lock helping to avoid concurrent configuration updates.
 */
export function putCatalogConfiguration(
    builder: RequestBuilder,
    params: { catalog: string; configuration: AdminConfiguration }
): Promise<any> {
    const baseUrl = "/v2/admin/catalog/{catalog}".replace(
        "{catalog}",
        UrlBuilder.toString(params.catalog)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.configuration !== undefined) {
        options.body = JSON.stringify(params.configuration);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Returns configuration of the layers and dataCatalogs of the catalog.
 *
 * @summary Get the catalog layer and dataCatalog configuration.
 */
export function getCatalogsConfiguration(builder: RequestBuilder): Promise<Configuration> {
    const baseUrl = "/v2/catalog/configuration";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Configuration>(urlBuilder, options);
}

/**
 *
 *
 * @summary Gets the metadata history associated with a partition.
 * @param layer The name of the layer that is requested. Content of this parameter must refer to a
 * valid layer already configured in the catalog configuration. Exactly one layer name has to be
 * provided.
 * @param partition Name of the queried partition. Restriction: Retrieving partitions with a leading
 * '/' character in their name is not supported on this resource.
 * @param version Version to begin search (inclusive).
 * @param direction Direction of search (`'previous'` or `'next'`), default is to search
 * for previous versions.
 * @param limit Limit of results. Default is 10, the maximum limit value allowed is 100.
 * @param additionalFields Additional fields being requested in the response. Possible fields are:
 * `checksum`, `dataSize`, and `compressedDataSize`. The fields need to be separated by a comma.
 */
export function getChangeHistory(
    builder: RequestBuilder,
    params: {
        layer: string;
        partition: string;
        version: number;
        direction?: string;
        limit?: number;
        additionalFields?: string[];
    }
): Promise<Partitions> {
    const baseUrl = "/v2/catalog/changeHistory/{layer}/{partition}"
        .replace("{layer}", UrlBuilder.toString(params.layer))
        .replace("{partition}", UrlBuilder.toString(params.partition));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("direction", params.direction);
    urlBuilder.appendQuery("limit", params.limit);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * Gets the changes between two versions of catalog. It will return only latest change for changed
 * partition, which happened in requested range not individual, intermediate changes of it. If in
 * the response for this request contains partitions with empty 'dataHandle' it means that the
 * partition was deleted at the version indicated by 'version' field of the partition objects.
 * Information about the partition deletion (empty 'dataHandle') might not be present in the
 * response when 'startVersion' and 'endVersion' parameters specify the version range surrounding
 * versions in which given partition was added and that later, within the specified range deleted.
 * In the absence of layer or partition parameters, all layers and partitions will be considered.
 * URI size and the filter defined by partition and layer parameters have the same limitations as
 * the /catalog/partitions endpoint.
 *
 * @summary Get metadata for partitions that changed between specified versions.
 * @param startVersion Start version (exclusive). It has to be valid catalog version or one less
 * than minimum not deleted version.
 * @param endVersion End version (inclusive). This has to be a valid catalog version greater than
 * the startVersion.
 * @param layer Layer names used for filtering. Multiple layers can be specified by using this
 * parameter multiple times. When absent, all layers are considered. Content of this parameter must
 * refer to a valid layer already configured in the catalog configuration.
 * @param partition Partition used for filtering. Multiple partitions can be specified by using this
 * parameter multiple times. When absent, all partitions are considered.
 * @param additionalFields Additional fields being requested in the response. Possible fields are:
 * `checksum`, `dataSize`, and `compressedDataSize`. The fields need to be separated by a comma.
 * @param range Parameter which can be used to resume download of big responses from specific byte
 * offset in case there was connection issue between client and server. This parameter should be
 * compliant with [RFC 7233](https://tools.ietf.org/html/rfc7233). Datastore supports only single
 * byte range, which should be offset like, i.e. &#x60;range&#x3D;bytes&#x3D;10-&#x60;.
 */
export function getChanges(
    builder: RequestBuilder,
    params: {
        startVersion: number;
        endVersion: number;
        layer?: string[];
        partition?: string[];
        additionalFields?: string[];
        range?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/v2/catalog/changes";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("layer", params.layer);
    urlBuilder.appendQuery("partition", params.partition);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * The purpose of this is to know the number of changed partitions in a specified version range of
 * the catalog before calling the catalog/changes endpoint. A token is returned that can be used to
 * obtain this information from the catalog/statistics/changeset endpoint.
 *
 * @summary Get a token that is used for the catalog/statistics/changeset endpoint.
 * @param startVersion Start version (exclusive). It has to be valid catalog version or one less
 * than minimum not deleted version.
 * @param endVersion End version (inclusive). This has to be a valid catalog version greater than
 * the startVersion.
 * @param body Queried layer names.
 */
export function getChangesStatistics(
    builder: RequestBuilder,
    params: { startVersion: number; endVersion: number; body?: ChangesetQuery }
): Promise<ChangesetStatisticsToken> {
    const baseUrl = "/v2/catalog/changes/changesetStatistics";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<ChangesetStatisticsToken>(urlBuilder, options);
}

/**
 * This allows users to see how many partitions have been changed before calling the catalog/changes
 * or catalog/partitions endpoints.
 *
 * @summary Get partitionCount and status for requested layers.
 * @param token Token retrieved from a call to either the catalog/changes/changesetStatistics or the
 * catalog/partitions/changesetStatistics endpoints.
 */
export function getChangesetStatistics(
    builder: RequestBuilder,
    params: { token: string }
): Promise<ChangesetStatistics> {
    const baseUrl = "/v2/catalog/statistics/changeset";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("token", params.token);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ChangesetStatistics>(urlBuilder, options);
}

/**
 * Returns general information about the catalog.
 *
 * @summary Get catalog metadata.
 */
export function getInfo(builder: RequestBuilder): Promise<CatalogInfo> {
    const baseUrl = "/v2/catalog/info";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<CatalogInfo>(urlBuilder, options);
}

/**
 * Returns latest version for the given catalog. If the catalog doesn't contain any versions 404
 * will be returned.
 *
 * @summary Get information about latest metadata store versions.
 * @param startVersion Last version that the client has discovered. If no versions have been
 * discovered so far, set the parameter to -1.
 */
export function getLatestVersion(
    builder: RequestBuilder,
    params: { startVersion: number }
): Promise<LatestVersion> {
    const baseUrl = "/v2/catalog/versions/latest";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<LatestVersion>(urlBuilder, options);
}

/**
 * Returns information about the catalog version. It will return an error if the catalog does not
 * have any versions or if the version passed in the query parameter does not exist.
 *
 * @summary Get the latest change per layer for a given version, layers without committed partitions
 * will be omitted.
 * @param version Catalog version.
 */
export function getLayerVersions(
    builder: RequestBuilder,
    params: { version: number }
): Promise<LayerVersions> {
    const baseUrl = "/v2/catalog/layerVersions";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<LayerVersions>(urlBuilder, options);
}

/**
 * Get partition data. The server may send an HTTP redirect pointing to the partition data.
 *
 * @summary Get the requested partition.
 * @param layer The name of the layer that is requested. Content of this parameter must refer to a
 * valid layer already configured in the catalog configuration. Exactly one layer name has to be
 * provided.
 * @param partition Name of the queried partition. Restriction: Retrieving partitions with a leading
 * '/' character in their name is not supported on this resource.
 * @param version Catalog version.
 */
export function getPartition(
    builder: RequestBuilder,
    params: { layer: string; partition: string; version: number }
): Promise<any> {
    const baseUrl = "/v2/catalog/partition/{layer}/{partition}"
        .replace("{layer}", UrlBuilder.toString(params.layer))
        .replace("{partition}", UrlBuilder.toString(params.partition));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * When no explicit filters are specified in query parameters, this call will internally scan the
 * entire catalog. If the required partitions are known, these should be queried explicitly. If the
 * layer specified in the request does not exist, an error is returned. If a partition specified in
 * the request does not exist, it is skipped in the response. The total URI length must not exceed
 * 2000 bytes. When the partition parameter is given, the filter defined by the 'layer' and
 * 'partition' parameters must limit the potential number of returned partitions to less than 1000.
 * For example, specifying a filter with 3 layers and 10 partitions is allowed (potentially 30
 * partitions in total), while specifying a filter with 30 layers and 40 partitions is not
 * (potentially 1200 partitions in total). If no layer filter is specified, the size of the layer
 * filter is the number of layers in that catalog. In other words, if the catalog holds 100 layers,
 * and only a partition filter is given, that filter must specify fewer than 10 partitions. When the
 * layer parameter is used without the partition parameter, there are no limitations on the number
 * of partitions considered and all partitions from matching layers are returned.
 *
 * @summary Get metadata for requested partitions.
 * @param version Catalog version.
 * @param layer Layer used for filtering. Multiple layers can be specified by using this parameter
 * multiple times. When absent, all layers are considered. Content of this parameter must refer to a
 * valid layers already configured in the catalog configuration.
 * @param partition Partition name used for filtering. Multiple partitions can be specified by using
 * this parameter multiple times. When absent, all partitions are considered.
 * @param additionalFields Additional fields being requested in the response. Possible fields are:
 * `checksum`, `dataSize`, and `compressedDataSize`. The fields need to be separated by a comma.
 * @param range Parameter which can be used to resume download of big responses from specific byte
 * offset in case there was connection issue between client and server. This parameter should be
 * compliant with [RFC 7233](https://tools.ietf.org/html/rfc7233). Datastore supports only single
 * byte range, which should be offset like, i.e. &#x60;range&#x3D;bytes&#x3D;10-&#x60;.
 */
export function getPartitions(
    builder: RequestBuilder,
    params: {
        version: number;
        layer?: string[];
        partition?: string[];
        additionalFields?: string[];
        range?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/v2/catalog/partitions";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("layer", params.layer);
    urlBuilder.appendQuery("partition", params.partition);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * The purpose of this is to be able to know the number of partitions in a specific version of the
 * catalog before calling the catalog/partitions endpoint. A token is returned that can be used to
 * obtain this information from the catalog/statistics/changeset endpoint.
 *
 * @summary Get a token that is used for the catalog/statistics/changeset endpoint.
 * @param version Catalog version.
 * @param body Queried layer names.
 */
export function getPartitionsStatistics(
    builder: RequestBuilder,
    params: { version: number; body?: ChangesetQuery }
): Promise<ChangesetStatisticsToken> {
    const baseUrl = "/v2/catalog/partitions/changesetStatistics";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<ChangesetStatisticsToken>(urlBuilder, options);
}

/**
 * Returns information about specific data version(s). 404 will be returned if the catalog doesn't
 * contain any versions.
 *
 * @summary Get information about metadata store versions.
 * @param startVersion Start version (exclusive). If the version specified has been deleted, the
 * lowest existing version is assumed.
 * @param endVersion End version (inclusive). This has to be a valid catalog version greater than
 * the startVersion. The maximum value for this parameter is returned from the
 * `'catalog/versions/latest'` endpoint, minimum is the first version returned by this endpoint with
 * startVersion&#x3D;-1 and some valid endVersion. If this version does not exist, 400 Bad Request
 * will be returned.
 * @param limit Maximum number of versions to be returned. Up to 1000 versions can be returned per
 * call. If not specified, 1000 is assumed. The versions are returned in ascending order (oldest
 * versions first). If the limit is reached, the latest versions will be filtered out.
 */
export function getVersions(
    builder: RequestBuilder,
    params: { startVersion: number; endVersion: number; limit?: number }
): Promise<VersionInfos> {
    const baseUrl = "/v2/catalog/versions";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);
    urlBuilder.appendQuery("limit", params.limit);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<VersionInfos>(urlBuilder, options);
}

/**
 * This call can be used instead of /catalog/partitions to avoid limitations of the URL length in
 * the request. The filter size limits are the same as for the getPartitions call.
 *
 * @summary Query metadata for requested partitions.
 * @param body Queried partitions.
 * @param additionalFields Additional fields being requested in the response. Possible fields are:
 * `checksum`, `dataSize`, and `compressedDataSize`. The fields need to be separated by a comma.
 * @param range Parameter which can be used to resume download of big responses from specific byte
 * offset in case there was connection issue between client and server. This parameter should be
 * compliant with [RFC 7233](https://tools.ietf.org/html/rfc7233). Datastore supports only single
 * byte range, which should be offset like, i.e. &#x60;range&#x3D;bytes&#x3D;10-&#x60;. Note that
 * accroding to [RFC 7233](https://tools.ietf.org/html/rfc7233) POST requests must ignore
 * &#x60;Range&#x60; header, additionally response status code 206 (Partial Content) is not a valid
 * status code for POST requests, thus when &#x60;range&#x60; query parameter is provided status
 * code for successful responses would be 200.
 */
export function queryPartitions(
    builder: RequestBuilder,
    params: { body: PartitionQuery; additionalFields?: string[]; range?: string }
): Promise<Partitions> {
    const baseUrl = "/v2/catalog/queryPartitions";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * This method will reset the catalog to the state as it was newly created with provided
 * configuration. Reset is functionally equivalent to removing and creating catalog again. It should
 * be used for testing purposes in order to set up test data before test execution. This method
 * should be used instead of removing and creating catalog as DataStore will not recreate catalog
 * DNS record and can do certain optimizations making the operation more reliable and faster.
 *
 * @summary Resets catalogs configuration and data.
 * @param configuration The configuration of the catalog.
 */
export function resetCatalog(
    builder: RequestBuilder,
    params: { configuration: CatalogConfiguration }
): Promise<any> {
    const baseUrl = "/v2/admin/reset";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.configuration !== undefined) {
        options.body = JSON.stringify(params.configuration);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Get configuration of a catalog.
 *
 * @summary Returns configuration of a catalog.
 */
export function getConfiguration(builder: RequestBuilder): Promise<CatalogConfiguration> {
    const baseUrl = "/v2/config";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<CatalogConfiguration>(urlBuilder, options);
}

/**
 * Puts configuration of a catalog.
 *
 * @summary Writes configuration of a catalog.
 * @param configuration The configuration of the catalog. If the catalog already exists, it will
 * overwrite any previous existing configuration. If body contains the catalog version property it
 * should match the current configuration version plus one. If the version is not provided DataStore
 * will automatically use next version. Client should provide explicit version as it will work as
 * optimistic lock helping to avoid concurrent configuration updates.
 */
export function putConfiguration(
    builder: RequestBuilder,
    params: { configuration: CatalogConfiguration }
): Promise<any> {
    const baseUrl = "/v2/config";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.configuration !== undefined) {
        options.body = JSON.stringify(params.configuration);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Get metadata for the requested index. Only available for layers where the partitioning scheme is
 * 'quadtree' (deprecated) or 'heretile'.
 *
 * @summary Get index metadata.
 * @param version Catalog version.
 * @param layer The name of the layer that is requested. Content of this parameter must refer to a
 * valid layer already configured in the catalog configuration. Exactly one layer name has to be
 * provided.
 * @param quadKey The geometric area of which an index is requested. Depending on the partitioning
 * scheme of the layer, either a 'quadtree' (deprecated) or a 'heretile' partition
 * id has to be passed in.
 * @param depth The recursion depth of the response. If set to 0, data is only returned for the
 * quadkey requested. Depth thus describes the maximum length of the `subQuadKeys` returned. The
 * maximum allowed value for the depth parameter is 4.
 * @param additionalFields Additional fields being requested in the response. Possible fields are:
 * `checksum`, `dataSize`, and `compressedDataSize`. The fields need to be separated by a comma.
 */
export function getIndex(
    builder: RequestBuilder,
    params: {
        version: number;
        layer: string;
        quadKey: string;
        depth: number;
        additionalFields?: string[];
    }
): Promise<Index> {
    const baseUrl = "/v2/index/{version}/{layer}/{quadKey}/{depth}"
        .replace("{version}", UrlBuilder.toString(params.version))
        .replace("{layer}", UrlBuilder.toString(params.layer))
        .replace("{quadKey}", UrlBuilder.toString(params.quadKey))
        .replace("{depth}", UrlBuilder.toString(params.depth));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Index>(urlBuilder, options);
}

/**
 * This method will return the subset of the CandidatePartitions that are either added (contained in
 * CandidatePartitions but not in baseVersion), deleted (marked as deleted in CandidatePartitions
 * and existing in baseVersion) or modified (have a changed checksum compared to the baseVersion).
 * This method is limited to comparing up to 1000 partitions.
 *
 * @summary Compare the proposed update to the content of the catalog and calculate changes.
 * @param baseVersion Base version which this compare is relative to. This parameter is used to
 * ensure that the commit will be relative to the version the client assumed, and no concurrent
 * commit was applied.
 * @param body Proposed update. Only calls with up to 1000 partitions are supported.
 */
export function compare(
    builder: RequestBuilder,
    params: { baseVersion: number; body: CandidatePartitions }
): Promise<ChangedPartitions> {
    const baseUrl = "/v2/publish/compare";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("baseVersion", params.baseVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<ChangedPartitions>(urlBuilder, options);
}

/**
 * This call permanently removes versions from the catalog. It can only be called for versions that
 * have completed retirement, so their `timeToLive` must have counted down to `0`.
 *
 * @summary Delete already retired versions.
 * @param newMinimumVersion All versions lower than newMinimumVersion will be permanently deleted.
 */
export function deleteRetiredVersions(
    builder: RequestBuilder,
    params: { newMinimumVersion: number }
): Promise<any> {
    const baseUrl = "/v2/publish/deleteRetiredVersions";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("newMinimumVersion", params.newMinimumVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Returns a list of partitions that will no longer be referenced if retired versions get deleted.
 * This list can be used by the catalog owner to know which dataHandles will no longer be accessed
 * and can be deleted.
 *
 * @summary Get a list of no longer needed partitions.
 */
export function getDeletableData(builder: RequestBuilder): Promise<DeletablePartitions> {
    const baseUrl = "/v2/publish/deletableData";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<DeletablePartitions>(urlBuilder, options);
}

/**
 * Aborts a multipart commit operation and deletes all related resources. The token will no longer
 * be valid after multipart abort operation.
 *
 * @summary Abort a multipart commit operation.
 * @param token Token retrieved from a call to /publish/multipart/start.
 */
export function multipartAbort(builder: RequestBuilder, params: { token: string }): Promise<any> {
    const baseUrl = "/v2/publish/multipart/abort";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("token", params.token);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * This call is used to commit uploaded parts to a new version of the catalog.
 *
 * @summary Commit uploaded parts to the catalog.
 * @param token Token retrieved from a call to /publish/multipart/start.
 * @param body List of parts to be included in the commit. The maximum number of parts supported in
 * one multipart commit operation is 100.
 */
export function multipartCommit(
    builder: RequestBuilder,
    params: { token: string; body: MultipartParts }
): Promise<any> {
    const baseUrl = "/v2/publish/multipart/commit";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("token", params.token);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Gets a new URL where to PUT data to be published. A `Content-Type` header with the content type
 * indicated in the response has to be set on the PUT request. The md5 of the uploaded body will be
 * needed to finish the multipart commit. Uploading to the returned URL is only possible for around
 * 30 minutes. Exact expiration time in UTC can be checked in the expiration field.
 *
 * @summary Gets a URL where additional data can be posted.
 * @param token Token retrieved from a call to /publish/multipart/start.
 * @param contentType Content type which will be used for uploading the part. Allowed values are
 * application/json. Uploading may fail if the `Content-Type` header of the PUT command does not
 * match this value. If this parameter is not present, application/json is assumed as default value.
 */
export function multipartGetPartUrl(
    builder: RequestBuilder,
    params: { token: string; contentType?: string }
): Promise<MultipartUrl> {
    const baseUrl = "/v2/publish/multipart/getPartUrl";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("token", params.token);
    urlBuilder.appendQuery("contentType", params.contentType);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<MultipartUrl>(urlBuilder, options);
}

/**
 * This call is used to start publishing a new multipart commit to a catalog. The returned token is
 * valid for 24 hours.
 *
 * @summary Starts publishing a new multipart commit to a catalog.
 * @param baseVersion The base version which this commit is relative to. Required to be the current
 * version of the catalog. This parameter is used to ensure that the commit will be relative to the
 * version the client assumed, and no concurrent commit was applied.
 * @param body Data necessary to start a multipart commit.
 */
export function multipartStart(
    builder: RequestBuilder,
    params: { baseVersion: number; body?: MultipartCommitRequest }
): Promise<MultipartToken> {
    const baseUrl = "/v2/publish/multipart/start";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("baseVersion", params.baseVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<MultipartToken>(urlBuilder, options);
}

/**
 * Get status of all ongoing multipart commits on this catalog.
 *
 * @summary Get status of multipart commit operations.
 * @param token If a token retrieved from a call to /publish/multipart/start is given here, only the
 * status for this token will be included in the response. Will return an error if the token is no
 * longer valid.
 */
export function multipartStatus(
    builder: RequestBuilder,
    params: { token?: string }
): Promise<MultipartStatuses> {
    const baseUrl = "/v2/publish/multipart/status";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("token", params.token);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<MultipartStatuses>(urlBuilder, options);
}

/**
 * All versions below the `newMinimumVersion` will be flagged with their retirement date, equal to
 * the current date + the version `timeToLive`.
 *
 * @summary Prepare retirement of versions in this catalog earlier than the given version.
 * @param newMinimumVersion All versions lower than `newMinimumVersion` will be retired.
 * `newMinimumVersion` must be a multiple of the SnapshotInterval.
 */
export function retire(
    builder: RequestBuilder,
    params: { newMinimumVersion: number }
): Promise<any> {
    const baseUrl = "/v2/publish/retire";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("newMinimumVersion", params.newMinimumVersion);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}
