/*
 * Copyright (C) 2018 HERE Global B.V. and its affiliate(s). All rights reserved.
 *
 * This software and other materials contain proprietary information controlled by HERE and are
 * protected by applicable copyright legislation. Any use and utilization of this software and other
 * materials and disclosure to any third parties is conditional upon having a separate agreement
 * with HERE for the access, use, utilization or disclosure of this software. In the absence of such
 * agreement, the use of the software is not allowed.
 */
import {
    createMaterial,
    DecodedTile,
    ExtrudedPolygonTechnique,
    FillTechnique,
    GeometryType,
    getArrayConstructor,
    getAttributeValue,
    getBufferAttribute,
    getObjectConstructor,
    getPropertyValue,
    isStandardTechnique,
    Technique,
    TextPathGeometry
} from "@here/datasource-protocol";
import { GeoBox, Projection, TileKey } from "@here/geoutils";
import {
    DashedLineMaterial,
    EdgeMaterial,
    EdgeMaterialParameters,
    SolidLineMaterial
} from "@here/materials";
import {
    TextHorizontalAlignment,
    TextHorizontalAlignmentStrings,
    TextVerticalAlignment,
    TextVerticalAlignmentStrings
} from "@here/text-renderer";
import { CachedResource, GroupedPriorityList, PerformanceTimer } from "@here/utils";
import * as THREE from "three";

import { ColorCache } from "./ColorCache";
import { DataSource } from "./DataSource";
import {
    applyDepthBasedPolygonOffset,
    createDepthPrePassMesh,
    DEFAULT_DEPTH_BASED_POLYGON_OFFSET_MULTIPLIER,
    isRenderDepthPrePassEnabled
} from "./DepthPrePass";
import { MapView } from "./MapView";
import { TextElement } from "./text/TextElement";
import { DEFAULT_TEXT_DISTANCE_SCALE } from "./text/TextElementsRenderer";
import { MapViewUtils } from "./Utils";

export type TileObject = THREE.Object3D & {
    /**
     * Distance of this object from the [[Tile]]'s center.
     */
    displacement?: THREE.Vector3;
};

interface DisposableObject {
    geometry?: THREE.BufferGeometry | THREE.Geometry;
    material?: THREE.Material[] | THREE.Material;
}

/**
 * Interface for optional feature data that is saved in the `userData` property of `THREE.Object3D`.
 */
export interface TileFeatureData {
    /**
     * Original type of geometry.
     */
    geometryType?: GeometryType;

    /**
     * Optional array of feature IDs.
     */
    ids?: Array<number | undefined>;

    /**
     * Optional array of the indices into geometry where the feature starts. The lists of ids and
     * starts have to have the same size.
     */
    starts?: number[];

    /**
     * Optional object containing properties defined by the end-user. It has the same size as the
     * list of ids and the starts.
     */
    objInfos?: Array<{} | undefined>;
}

/**
 * Data describing the road data on a `tile`. The `RoadIntersectionData` is generated by the class
 * [[RoadPicker]].
 *
 * @see [[RoadPicker]]
 */
export interface RoadIntersectionData {
    /**
     * Optional array of feature IDs.
     */
    ids: Array<number | undefined>;

    /**
     * Array of the indices into the technique catalog. The lists of `techniqueIndex` and `starts`
     * have the same size.
     */
    techniqueIndex: number[];

    /**
     * Array of the indices into geometry where the feature starts. The lists of ids and starts have
     * the same size.
     */
    starts: number[];

    /**
     * Array of the widths of the roads. The lists of ids and widths have the same size.
     */
    widths: number[];

    /**
     * Array of 2D numbers making up the road geometry.
     */
    positions: number[];

    /**
     * Catalog of [[Technique]]s for the road lines. Allows to reconstruct the visual appearance of
     * the identified line.
     */
    techniques: Technique[];
}

/**
 * Missing Typedoc
 */
export enum TileLoaderState {
    Initialized,
    Loading,
    Loaded,
    Decoding,
    Ready,
    Canceled,
    Failed,
    Disposed
}

export interface ITileLoader {
    state: TileLoaderState;
    payload?: ArrayBufferLike | {};
    decodedTile?: DecodedTile;

    loadAndDecode(): Promise<TileLoaderState>;
    waitSettled(): Promise<TileLoaderState>;

    cancel(): void;
    dispose(): void;

    isFinished(): boolean;
}

/**
 * Object containing information about resources used by tile.
 */
export interface TileResourceUsageInfo {
    /**
     * Estimated memory usage, in bytes.
     */
    estimatedMemoryUsage: number;
    /**
     * Amount of vertices used by tile.
     */
    numVertices: number;
    /**
     * Amount of colors used by tile.
     */
    numColors: number;
    /**
     * Amount of objects used by tile.
     */
    numObjects: number;
    /**
     * Amount of geometries used by tile.
     */
    numGeometries: number;
    /**
     * Amount of materials used by tile.
     */
    numMaterials: number;
}

/**
 * While generating [[TextElement]]s from the [[DecodedTile]], their priority is modified a bit to
 * get a meaningful priority and stable results.
 */

/**
 * Amount of influence the original position has on rendering the [[TextElement]]. Sorts point
 * labels (who have no path length) as well as those with a path, like roads.
 */
const SORT_WEIGHT_SEQUENCE = 0.1;

/**
 * Give [[TextElement]]s with a longer paths a higher priority since they will be easier to place,
 * so they will actually more often be placed than not. In case of a resource limit, less labels
 * will be checked.
 */
const SORT_WEIGHT_PATH_LENGTH = 1.0 - SORT_WEIGHT_SEQUENCE;

/**
 * Factor used for memory estimation.
 */
const MEMORY_UNDERESTIMATION_FACTOR = 2;

/**
 * The class `Tile` holds the tiled data of a [[DataSource]].
 */
export class Tile implements CachedResource {
    /**
     * List of the THREE.js objects stored in this `Tile`.
     */
    readonly objects: TileObject[] = [];

    /**
     * The optional list of HERE tile keys of tiles with geometries crossing
     * the boundaries of this `Tile`.
     */
    readonly dependencies: string[] = new Array<string>();

    /**
     * The bounding box of this `Tile` in geo coordinates.
     */
    readonly geoBox: GeoBox;

    /**
     * The bounding box of this `Tile` in world coordinates.
     */
    readonly boundingBox: THREE.Box3 = new THREE.Box3();

    /**
     * The center of this `Tile` in world coordinates.
     */
    readonly center: THREE.Vector3 = new THREE.Vector3();

    /**
     * Record of road data that cannot be intersected with THREE.JS, because the geometry is
     * created in the vertex shader.
     */
    roadIntersectionData?: RoadIntersectionData;

    private m_disposed: boolean = false;

    private m_forceHasGeometry: boolean | undefined = undefined;

    private m_tileLoader?: ITileLoader;
    private m_decodedTile?: DecodedTile;

    /**
     * Prepared text geometries optimized for display.
     */
    private m_preparedTextPaths: TextPathGeometry[] = new Array();

    // Used for user defined [[TextElement]]s.
    private readonly m_userTextElements: TextElement[] = [];

    // Used for [[TextElement]]s that are stored in the data, and that are placed explicitely,
    // fading in and out.
    private readonly m_textElementGroups: GroupedPriorityList<
        TextElement
    > = new GroupedPriorityList<TextElement>();

    // All visible [[TextElement]]s.
    private readonly m_placedTextElements: GroupedPriorityList<
        TextElement
    > = new GroupedPriorityList<TextElement>();
    private m_numVertices: number = 0;

    private m_memoryUsage: number | undefined = undefined;

    // If `true`, the text content of the [[Tile]] changed.
    private m_textElementsChanged: boolean = false;

    /**
     * Creates a new `Tile`.
     *
     * @param dataSource The [[DataSource]] that created this `Tile`.
     * @param tileKey The [[TileKey]] of this `Tile`.
     */
    constructor(readonly dataSource: DataSource, readonly tileKey: TileKey) {
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.projection.projectBox(this.geoBox, this.boundingBox);
        this.boundingBox.getCenter(this.center);
    }

    /**
     * The [[Projection]] currently used by the [[MapView]].
     */
    get projection(): Projection {
        return this.dataSource.projection;
    }

    /**
     * The [[MapView]] this `Tile` belongs to.
     */
    get mapView(): MapView {
        return this.dataSource.mapView;
    }

    /**
     * Get the currently visible [[TextElement]]s of this `Tile`. This list will be modified
     * continuously, and it is not designed to be used to store user defined [[TextElements]].
     */
    get placedTextElements(): GroupedPriorityList<TextElement> {
        return this.m_placedTextElements;
    }

    /*
     * The size of Tile in system memory.
     */
    get memoryUsage(): number {
        if (this.m_memoryUsage !== undefined) {
            return this.m_memoryUsage;
        }
        let numBytesUsed = 0;
        if (this.decodedTile !== undefined) {
            numBytesUsed += MapViewUtils.estimateObjectSize(this.decodedTile);
        }
        numBytesUsed += MapViewUtils.estimateObjectSize(this.textElementGroups);
        numBytesUsed += MapViewUtils.estimateObjectSize(this.objects);
        numBytesUsed += MapViewUtils.estimateObjectSize(this.preparedTextPaths);
        if (this.roadIntersectionData) {
            numBytesUsed += MapViewUtils.estimateObjectSize(this.roadIntersectionData);
        }
        this.m_memoryUsage = numBytesUsed;
        return numBytesUsed * MEMORY_UNDERESTIMATION_FACTOR;
    }

    /**
     * Detailed information about objects used by Tile.
     */
    getUsageStatistics(): TileResourceUsageInfo {
        const renderInfo: TileResourceUsageInfo = {
            estimatedMemoryUsage: this.memoryUsage,
            numVertices: this.m_numVertices,
            numColors: ColorCache.instance.size,
            numObjects: this.objects.length,
            numGeometries:
                this.m_decodedTile !== undefined ? this.m_decodedTile.geometries.length : 0,
            numMaterials: this.getMaterialsCount()
        };
        return renderInfo;
    }

    /**
     * Get the list of user [[TextElement]] of this `Tile`. This list of [[TextElement]]s will
     * always be rendered first.
     */
    get userTextElements(): TextElement[] {
        return this.m_userTextElements;
    }

    /**
     * Add a user [[TextElement]] to this `Tile`. It will always be visible (if its location is in
     * the currently visible area of the map).
     *
     * @param textElement Text element to add.
     */
    addUserTextElement(textElement: TextElement) {
        this.m_userTextElements.push(textElement);
        this.textElementsChanged = true;
    }

    /**
     * Remove a user [[TextElement]] from this `Tile`.
     *
     * @param textElement User text element to remove.
     * @returns `True` if the element has been succesfully removed, `false` otherwise.
     */
    removeUserTextElement(textElement: TextElement): boolean {
        const foundIndex = this.m_userTextElements.indexOf(textElement);
        if (foundIndex >= 0) {
            this.m_userTextElements.splice(foundIndex, 1);
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }

    /**
     * Add a [[TextElement]] to this `Tile`. It will be added to the visible set of [[TextElement]]s
     * based on capacity and visibilities. The priority of the [[TextElement]] will control when
     * (or if) the `textElement` will become visible.
     *
     * To ensure that an element is visible, apply a high value to its priority, for example
     * `Number.MAX_SAFE_INTEGER`. Since there is a limit for visible text elements, not all text
     * elements may be visible at all times.
     *
     * @param textElement Text element to add.
     */
    addTextElement(textElement: TextElement) {
        this.textElementGroups.add(textElement);
        this.textElementsChanged = true;
    }

    /**
     * Remove a [[TextElement]] from this `Tile`. For the element to be removed successfully, the
     * priority of the [[TextElement]] has to be equal to its priority when it had been added.
     *
     * @param textElement Text element to remove.
     * @returns `True` if the element has been succesfully removed, `false` otherwise.
     */
    removeTextElement(textElement: TextElement): boolean {
        if (this.textElementGroups.remove(textElement)) {
            this.textElementsChanged = true;
            return true;
        }
        return false;
    }

    /**
     * Get the current [[GroupedPriorityList]], the list of all [[TextElement]]s to be selected and
     * placed for rendering.
     */
    get textElementGroups(): GroupedPriorityList<TextElement> {
        return this.m_textElementGroups;
    }

    /**
     * The current modification state of the list of [[TextElement]]s of the `Tile`. If the value
     * is `true` the text elements will be placed for rendering during the next frame.
     */
    get textElementsChanged(): boolean {
        return this.m_textElementsChanged;
    }

    set textElementsChanged(changed: boolean) {
        this.m_textElementsChanged = changed;
    }

    /**
     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.
     */
    prepareForRender() {
        if (!this.m_decodedTile || this.m_disposed) {
            return;
        }
        const decodedTile = this.m_decodedTile;

        if (decodedTile.tileInfo !== undefined) {
            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);
        }

        this.m_decodedTile = undefined;

        setTimeout(() => {
            const stats = this.mapView.statistics;
            let now = 0;
            if (stats.enabled) {
                now = PerformanceTimer.now();
            }

            this.createGeometries(decodedTile);

            if (stats.enabled) {
                stats.getTimer("geometryCreation").setValue(PerformanceTimer.now() - now);
            }

            this.dataSource.requestUpdate();
        }, 0);
    }

    /**
     * Called before [[MapView]] will start rendering this `Tile`.
     *
     * @param zoomLevel The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered.
     */
    willRender(_zoomLevel: number): boolean {
        return true;
    }

    /**
     * Called after [[MapView]] did render this `Tile`.
     */
    didRender(): void {
        // to be overriden by subclasses
    }

    /**
     * Called after the `Tile` has been decoded.
     *
     * @param decodedTile The [[DecodedTile]].
     */
    createGeometries(decodedTile: DecodedTile) {
        this.clear();
        this.preparePois(decodedTile);
        this.createTextElements(decodedTile);
        this.createObjects(decodedTile, this.objects);
        this.countVertices();
    }

    /**
     * The decoded tile, will be removed after geometry handling.
     */
    get decodedTile(): DecodedTile | undefined {
        return this.m_decodedTile;
    }

    /**
     * Called by [[TileLoader]] when data for geometry is available.
     *
     * @param decodedTile
     */
    setDecodedTile(decodedTile: DecodedTile) {
        this.m_decodedTile = decodedTile;
        this.invalidateUsageInfoCache();

        const dataSource = this.dataSource;
        const stats = dataSource.mapView.statistics;
        if (stats.enabled) {
            stats.getTimer("decoding").setValue(decodedTile.decodeTime);
        }
    }

    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object The object referencing the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectGeometry(object: TileObject): boolean {
        return true;
    }

    /**
     * Called when the default implementation of `dispose()` needs
     * to free the material of a `Tile` object.
     *
     * @param object The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    // tslint:disable-next-line:no-unused-variable
    shouldDisposeObjectMaterial(object: TileObject): boolean {
        return true;
    }

    /**
     * `true` if this `Tile` has been disposed.
     */
    get disposed(): boolean {
        return this.m_disposed;
    }

    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, just checks if the [[objects]] list is not empty but can be overridden by
     * manually setting this property.
     */
    get hasGeometry(): boolean {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        } else {
            return this.m_forceHasGeometry;
        }
    }

    /**
     * Overrides default [[hasGeometry]] value.
     *
     * @param value New value of the [[hasGeometry]] flag.
     */
    forceHasGeometry(value: boolean) {
        this.m_forceHasGeometry = value;
    }

    /**
     * Get the [[ITileLoader]] that manages this tile.
     */
    get tileLoader(): ITileLoader | undefined {
        return this.m_tileLoader;
    }

    /**
     * Set the [[ITileLoader]] that manages this tile.
     *
     * @param tileLoader [[ITileLoader]] instance will manage loading process for this tile.
     */
    set tileLoader(tileLoader: ITileLoader | undefined) {
        this.m_tileLoader = tileLoader;
    }

    /**
     * Force update of this `Tile` geometry.
     */
    reload() {
        this.dataSource.updateTile(this);
    }

    /**
     * Free the rendering resources allocated by this `Tile`.
     *
     * The default implementation of this method frees the geometries and
     * the materials of all the reachable objects.
     */
    clear() {
        const disposeObject = (object: TileObject & DisposableObject) => {
            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {
                object.geometry.dispose();
            }

            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        };

        this.objects.forEach((rootObject: TileObject & DisposableObject) => {
            rootObject.traverse((object: TileObject & DisposableObject) => {
                disposeObject(object);
            });

            disposeObject(rootObject);
        });

        this.objects.length = 0;
        if (this.m_preparedTextPaths) {
            this.m_preparedTextPaths = [];
        }

        this.placedTextElements.clear();
        this.textElementGroups.clear();
        this.userTextElements.length = 0;
        this.invalidateUsageInfoCache();
    }

    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.dispose();
            this.m_tileLoader = undefined;
        }
        this.clear();
        this.userTextElements.length = 0;
        this.m_disposed = true;
    }

    /**
     * Prepared text geometries optimized for display.
     */
    get preparedTextPaths(): TextPathGeometry[] {
        return this.m_preparedTextPaths;
    }

    /**
     * Split text paths that contain sharp corners.
     *
     * @param textPathGeometries Original path geometries that may have defects.
     */
    prepareTextPaths(textPathGeometries: TextPathGeometry[]): TextPathGeometry[] {
        const processedPaths = new Array<TextPathGeometry>();

        const MAX_CORNER_ANGLE = Math.PI / 8;

        const newPaths = textPathGeometries.slice();

        // maximum reuse of variables to reduce allocations
        const p0 = new THREE.Vector2();
        const p1 = new THREE.Vector2();
        const previousTangent = new THREE.Vector2();

        while (newPaths.length > 0) {
            const textPath = newPaths.pop();

            if (textPath === undefined) {
                break;
            }

            let splitIndex = -1;

            for (let i = 0; i < textPath.path.length - 2; i += 2) {
                p0.set(textPath.path[i], textPath.path[i + 1]);
                p1.set(textPath.path[i + 2], textPath.path[i + 3]);
                const tangent = p1.sub(p0).normalize();

                if (i > 0) {
                    const theta = Math.atan2(
                        previousTangent.x * tangent.y - tangent.x * previousTangent.y,
                        tangent.dot(previousTangent)
                    );

                    if (Math.abs(theta) > MAX_CORNER_ANGLE) {
                        splitIndex = i;
                        break;
                    }
                }
                previousTangent.set(tangent.x, tangent.y);
            }

            if (splitIndex > 0) {
                // split off the valid first path points with a clone of the path
                const firstTextPath = {
                    path: textPath.path.slice(0, splitIndex + 2),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };

                processedPaths.push(firstTextPath);

                // setup a second part with the rest of the path points and process again
                const secondTextPath = {
                    path: textPath.path.slice(splitIndex),
                    text: textPath.text,
                    // Used for placement priorities only, can be kept although it could also be
                    // recomputed
                    pathLengthSqr: textPath.pathLengthSqr,
                    technique: textPath.technique,
                    featureId: textPath.featureId
                };

                newPaths.push(secondTextPath);
            } else {
                processedPaths.push(textPath);
            }
        }
        return processedPaths;
    }

    /**
     * Create [[TextElement]] objects from the given decoded tile and list of materials. The
     * priorities of the [[TextElement]]s are updated to simplify label placement.
     *
     * @param decodedTile The [[DecodedTile]].
     */
    createTextElements(decodedTile: DecodedTile) {
        const colorMap = new Map<number, THREE.Color>();

        // gather the sum of [[TextElement]]s (upper boundary), to compute the priority, such that
        // the text elements that come first get the highest priority, so they get placed first.
        let numTextElements = 0;
        let numTextElementsCreated = 0;

        if (decodedTile.textPathGeometries !== undefined) {
            numTextElements += decodedTile.textPathGeometries.length;
        }
        if (decodedTile.textGeometries !== undefined) {
            numTextElements += decodedTile.textGeometries.length;
        }

        if (decodedTile.textPathGeometries !== undefined) {
            this.m_preparedTextPaths = this.prepareTextPaths(decodedTile.textPathGeometries);

            // Compute maximum street length (squared). Longer streets should be labelled first,
            // they have a higher chance of being placed in case the number of text elements is
            // limited.
            let maxPathLengthSqr = 0;
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique.name !== "text") {
                    continue;
                }
                if (textPath.pathLengthSqr > maxPathLengthSqr) {
                    maxPathLengthSqr = textPath.pathLengthSqr;
                }
            }

            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique.name !== "text") {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, ColorCache.instance.getColor(technique.color));
                }
                const path: THREE.Vector2[] = [];
                for (let i = 0; i < textPath.path.length; i += 2) {
                    path.push(new THREE.Vector2(textPath.path[i], textPath.path[i + 1]));
                }

                // Make sorting stable and make pathLengthSqr a differentiator for placement.
                const priority =
                    (technique.priority !== undefined ? technique.priority : 0) +
                    (SORT_WEIGHT_SEQUENCE * (numTextElements - numTextElementsCreated)) /
                        numTextElements +
                    (maxPathLengthSqr > 0
                        ? (SORT_WEIGHT_PATH_LENGTH * textPath.pathLengthSqr) / maxPathLengthSqr
                        : 0);

                const textElement = new TextElement(
                    textPath.text,
                    path,
                    priority,
                    technique.scale !== undefined ? technique.scale : 1.0,
                    technique.xOffset !== undefined ? technique.xOffset : 0.0,
                    technique.yOffset !== undefined ? technique.yOffset : 0.0,
                    textPath.featureId,
                    technique.style
                );
                textElement.bold = technique.bold;
                textElement.oblique = technique.oblique;
                textElement.color = colorMap.get(textPath.technique);
                textElement.minZoomLevel = technique.minZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : DEFAULT_TEXT_DISTANCE_SCALE;
                if (technique.tracking !== undefined) {
                    textElement.tracking = technique.tracking;
                }
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;

                if (
                    technique.hAlignment !== undefined &&
                    (technique.hAlignment === TextHorizontalAlignmentStrings.Left ||
                        technique.hAlignment === TextHorizontalAlignmentStrings.Center ||
                        technique.hAlignment === TextHorizontalAlignmentStrings.Right)
                ) {
                    textElement.horizontalAlignment = TextHorizontalAlignment[technique.hAlignment];
                }
                if (
                    technique.vAlignment !== undefined &&
                    (technique.vAlignment === TextVerticalAlignmentStrings.Above ||
                        technique.vAlignment === TextVerticalAlignmentStrings.Center ||
                        technique.vAlignment === TextVerticalAlignmentStrings.Below)
                ) {
                    textElement.verticalAlignment = TextVerticalAlignment[technique.vAlignment];
                }

                this.addTextElement(textElement);
                numTextElementsCreated++;
            }
        }

        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }

                const technique = decodedTile.techniques[text.technique];

                if (technique.name !== "text") {
                    continue;
                }

                if (technique.color !== undefined) {
                    colorMap.set(text.technique, ColorCache.instance.getColor(technique.color));
                }
                const positions = new THREE.BufferAttribute(
                    new Float32Array(text.positions.buffer),
                    text.positions.itemCount
                );

                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }

                // Keep TextElements sorted. The builtin sorting method is not stable, and a stable
                // sorting should reduce flicker of labels.
                const priority =
                    (technique.priority !== undefined ? technique.priority : 0) +
                    (SORT_WEIGHT_SEQUENCE * (numTextElements - numTextElementsCreated)) /
                        numTextElements;
                const singleElementPriorityFactor = SORT_WEIGHT_SEQUENCE / numPositions;

                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }

                    const singleElementPriority =
                        priority +
                        (singleElementPriorityFactor * (numPositions - i)) / numPositions;

                    const textElement = new TextElement(
                        label!,
                        new THREE.Vector2(x, y),
                        singleElementPriority,
                        technique.scale || 1.0,
                        technique.xOffset || 0.0,
                        technique.yOffset || 0.0,
                        text.featureId,
                        technique.style
                    );
                    textElement.color = colorMap.get(text.technique);
                    textElement.minZoomLevel = technique.minZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    this.addTextElement(textElement);
                    numTextElementsCreated++;
                }
            }
        }
    }

    /**
     * Add a THREE object  to the root of the tile. Sets the owning tiles datasource.name and the
     * tileKey in the property `userData` of the object, such that the tile it belongs to can be
     * identified during picking.
     *
     * @param object Object to add to root of tile.
     */
    registerTileObject(object: THREE.Object3D) {
        const userData = object.userData || {};
        userData.tileKey = this.tileKey;
        userData.dataSource = this.dataSource.name;
    }

    /**
     * Create `Tile` objects from the given decoded tile and list of materials.
     *
     * @param decodedTile The [[DecodedTile]].
     * @param objects The current list of tile objects.
     */
    createObjects(decodedTile: DecodedTile, objects: TileObject[]) {
        const materials: THREE.Material[] = [];
        for (const srcGeometry of decodedTile.geometries) {
            const groups = srcGeometry.groups;
            const groupCount = groups.length;

            for (let groupIndex = 0; groupIndex < groupCount; ) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];

                let count = group.count;

                // compress consecutive groups
                for (
                    ;
                    groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex;
                    ++groupIndex
                ) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }

                    count += groups[groupIndex].count;
                }

                const ObjectCtor = getObjectConstructor(technique);

                if (ObjectCtor === undefined) {
                    continue;
                }

                let material: THREE.Material | undefined = materials[techniqueIndex];

                if (material === undefined) {
                    material = createMaterial({
                        technique: decodedTile.techniques[techniqueIndex],
                        level: this.tileKey.level,
                        fog: this.mapView.scene.fog !== null
                    });
                    if (material === undefined) {
                        continue;
                    }
                    materials[techniqueIndex] = material;
                }

                const bufferGeometry = new THREE.BufferGeometry();

                srcGeometry.vertexAttributes.forEach(vertexAttribute => {
                    const buffer = getBufferAttribute(vertexAttribute);
                    bufferGeometry.addAttribute(vertexAttribute.name, buffer);
                });

                if (srcGeometry.interleavedVertexAttributes !== undefined) {
                    srcGeometry.interleavedVertexAttributes.forEach(attr => {
                        const ArrayCtor = getArrayConstructor(attr.type);
                        const buffer = new THREE.InterleavedBuffer(
                            new ArrayCtor(attr.buffer),
                            attr.stride
                        );
                        attr.attributes.forEach(interleavedAttr => {
                            const attribute = new THREE.InterleavedBufferAttribute(
                                buffer,
                                interleavedAttr.itemSize,
                                interleavedAttr.offset,
                                false
                            );
                            bufferGeometry.addAttribute(interleavedAttr.name, attribute);
                        });
                    });
                }

                if (srcGeometry.index) {
                    bufferGeometry.setIndex(getBufferAttribute(srcGeometry.index));
                }

                if (!bufferGeometry.getAttribute("normal") && isStandardTechnique(technique)) {
                    bufferGeometry.computeVertexNormals();
                }

                bufferGeometry.addGroup(start, count);

                if (technique.name === "solid-line" || technique.name === "dashed-line") {
                    const lineMaterial = material as THREE.RawShaderMaterial;
                    lineMaterial.uniforms.opacity.value = material.opacity;

                    if (technique.clipping !== false) {
                        const tileSize = lineMaterial.uniforms.tileSize;
                        const size = new THREE.Vector3();
                        this.boundingBox.getSize(size);
                        tileSize.value.x = size.x;
                        tileSize.value.y = size.y;
                        lineMaterial.defines.TILE_CLIP = 1;
                    }
                }

                // Add polygon offset to the extruded buildings and to the fill area to avoid depth
                // problems when rendering edges.
                const isExtruded: boolean =
                    technique.name === "extruded-polygon" && srcGeometry.edgeIndex !== undefined;
                const isFilled: boolean =
                    technique.name === "fill" && srcGeometry.outlineIndicesAttributes !== undefined;
                if (isExtruded || isFilled) {
                    material.polygonOffset = true;
                    material.polygonOffsetFactor = 0.25;
                    material.polygonOffsetUnits = 0.1;
                }

                const object = new ObjectCtor(bufferGeometry, material);

                object.frustumCulled = false;

                if (technique.renderOrder !== undefined) {
                    object.renderOrder = technique.renderOrder;
                } else {
                    if (technique._renderOrderAuto === undefined) {
                        throw new Error("Technique has no renderOrderAuto");
                    }
                    object.renderOrder = technique._renderOrderAuto;
                }

                if (group.renderOrderOffset !== undefined) {
                    object.renderOrder += group.renderOrderOffset;
                }

                if (srcGeometry.uuid !== undefined) {
                    object.userData.geometryId = srcGeometry.uuid;
                }

                // Lines renderOrder fix: Render them as transparent objects, but make sure they end
                // up in the opaque rendering queue (by disabling transparency onAfterRender, and
                // enabling it onBeforeRender).
                if (technique.name === "solid-line" || technique.name === "dashed-line") {
                    object.onBeforeRender = (renderer, scene, camera, geom, mat) => {
                        const lineMaterial = mat as SolidLineMaterial;
                        lineMaterial.transparent = true;

                        // Modify the lineWidth every frame for "Pixel-wide" lines.
                        const metricUnits = getAttributeValue(
                            technique.metricUnit,
                            this.tileKey.level
                        );
                        if (metricUnits === "Pixel") {
                            const pixelToWorld =
                                renderer.getPixelRatio() * this.mapView.pixelToWorld * 0.5;
                            const lineWidth = getAttributeValue(
                                technique.lineWidth,
                                this.tileKey.level
                            );
                            lineMaterial.lineWidth =
                                (lineWidth !== undefined
                                    ? (lineWidth as number)
                                    : SolidLineMaterial.DEFAULT_WIDTH) * pixelToWorld;

                            // Do the same for dashSize and gapSize for dashed lines.
                            if (technique.name === "dashed-line") {
                                const dashedLineMaterial = lineMaterial as DashedLineMaterial;

                                const dashSize = getAttributeValue(
                                    technique.dashSize,
                                    this.tileKey.level
                                );
                                dashedLineMaterial.dashSize =
                                    (dashSize !== undefined
                                        ? (dashSize as number)
                                        : DashedLineMaterial.DEFAULT_DASH_SIZE) * pixelToWorld;

                                const gapSize = getAttributeValue(
                                    technique.gapSize,
                                    this.tileKey.level
                                );
                                dashedLineMaterial.gapSize =
                                    (gapSize !== undefined
                                        ? (gapSize as number)
                                        : DashedLineMaterial.DEFAULT_GAP_SIZE) * pixelToWorld;
                            }
                        }
                    };
                    object.onAfterRender = (renderer, scene, camera, geom, mat) => {
                        const lineMaterial = mat as SolidLineMaterial;
                        lineMaterial.transparent = false;
                    };
                }

                // pass the feature data on to the object, so it can be used in picking
                // MapView.intersectMapObjects()
                if (srcGeometry.featureIds !== undefined && srcGeometry.featureIds.length > 0) {
                    const featureData: TileFeatureData = {
                        geometryType: srcGeometry.type,
                        ids: srcGeometry.featureIds,
                        starts: srcGeometry.featureStarts
                    };
                    object.userData.feature = featureData;

                    if (srcGeometry.objInfos !== undefined) {
                        object.userData.feature.objInfos = srcGeometry.objInfos;
                    }
                }

                const renderDepthPrePass =
                    technique.name === "extruded-polygon" && isRenderDepthPrePassEnabled(technique);

                if (renderDepthPrePass) {
                    const depthPassMesh = createDepthPrePassMesh(object as THREE.Mesh);
                    objects.push(depthPassMesh);

                    applyDepthBasedPolygonOffset(
                        DEFAULT_DEPTH_BASED_POLYGON_OFFSET_MULTIPLIER,
                        depthPassMesh,
                        object as THREE.Mesh
                    );
                }

                this.registerTileObject(object);

                objects.push(object);

                // Add the extruded building edges as a separate geometry.
                if (technique.name === "extruded-polygon" && srcGeometry.edgeIndex !== undefined) {
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.addAttribute("position", bufferGeometry.getAttribute("position"));
                    edgeGeometry.addAttribute("color", bufferGeometry.getAttribute("color"));
                    edgeGeometry.setIndex(getBufferAttribute(srcGeometry.edgeIndex));

                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;
                    const color =
                        extrudedPolygonTechnique.lineColor !== undefined
                            ? extrudedPolygonTechnique.lineColor
                            : EdgeMaterial.DEFAULT_COLOR;
                    const colorMix =
                        extrudedPolygonTechnique.lineColorMix !== undefined
                            ? extrudedPolygonTechnique.lineColorMix
                            : EdgeMaterial.DEFAULT_COLOR_MIX;
                    const fadeDistance =
                        extrudedPolygonTechnique.lineFadeDistance !== undefined
                            ? extrudedPolygonTechnique.lineFadeDistance
                            : EdgeMaterial.DEFAULT_FADE_DIST;

                    // Configure the edge material based on the theme values.
                    const materialParams: EdgeMaterialParameters = {
                        color,
                        colorMix,
                        fadeDistance
                    };
                    const edgeMaterial = new EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);

                    // Set the correct render order (based on transparency).
                    edgeObj.renderOrder =
                        edgeMaterial.transparent && !renderDepthPrePass
                            ? -1
                            : object.renderOrder + 0.1;

                    // Translate linear fade distance to a depth value.
                    // tslint:disable-next-line:no-unused-variable
                    edgeObj.onBeforeRender = (renderer, scene, camera, geometry, mat) => {
                        const edgeMat = mat as EdgeMaterial;
                        edgeMat.fadeDistance = MapViewUtils.calculateDepthFromClipDistance(
                            fadeDistance,
                            camera
                        );
                    };

                    this.registerTileObject(edgeObj);
                    objects.push(edgeObj);
                }

                // polygon outline
                if (isFilled && srcGeometry.outlineIndicesAttributes !== undefined) {
                    // iterate through all the arrays inside the outlineIndicesAttributes for each
                    // of them, create an object and add it to objects
                    for (const indices of srcGeometry.outlineIndicesAttributes) {
                        const outlineGeometry = new THREE.BufferGeometry();
                        outlineGeometry.addAttribute(
                            "position",
                            bufferGeometry.getAttribute("position")
                        );
                        if (indices !== undefined) {
                            outlineGeometry.setIndex(getBufferAttribute(indices));
                        }

                        const fillTechnique = technique as FillTechnique;
                        const color =
                            fillTechnique.lineColor !== undefined
                                ? fillTechnique.lineColor
                                : EdgeMaterial.DEFAULT_COLOR;
                        const colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;

                        let fadeDistance = getPropertyValue(
                            fillTechnique.lineFadeDistance,
                            this.tileKey.level
                        );

                        fadeDistance =
                            fadeDistance !== undefined
                                ? fadeDistance
                                : EdgeMaterial.DEFAULT_FADE_DIST;

                        // Configure the edge material based on the theme values.
                        const materialParams: EdgeMaterialParameters = {
                            color,
                            colorMix,
                            fadeDistance
                        };
                        const outlineMaterial = new EdgeMaterial(materialParams);
                        const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);
                        outlineObj.renderOrder = object.renderOrder + 0.1;

                        // tslint:disable-next-line:no-unused-variable
                        outlineObj.onBeforeRender = (renderer, scene, camera, geom, mat) => {
                            const edgeMat = mat as EdgeMaterial;
                            edgeMat.fadeDistance = MapViewUtils.calculateDepthFromClipDistance(
                                fadeDistance!,
                                camera
                            );
                        };
                        // As threejs internally is rendering the transparent objects last,
                        // regardless of their renderOrder value, we set the transparent value
                        // to false in the onAfterRenderCall. In the onBeforeRender, the function
                        // calculateDepthFromClipDistance sets it to true if the fade distance value
                        // is less than 1.
                        // tslint:disable-next-line:no-unused-variable
                        outlineObj.onAfterRender = (renderer, scene, camera, geom, mat) => {
                            const edgeMat = mat as EdgeMaterial;
                            edgeMat.transparent = false;
                        };

                        this.registerTileObject(outlineObj);
                        objects.push(outlineObj);
                    }
                }
            }
        }
    }

    /**
     * Invalidates resource usage data.
     */
    invalidateUsageInfoCache(): void {
        this.m_numVertices = 0;
        this.m_memoryUsage = undefined;
    }

    /**
     * Counts vertices in the tile.
     */
    countVertices(): void {
        this.objects.filter(object => object instanceof THREE.Mesh).forEach(object => {
            const mesh = object as THREE.Mesh;
            if (mesh.geometry instanceof THREE.BufferGeometry) {
                if (mesh.geometry.index !== undefined && mesh.geometry.index !== null) {
                    this.m_numVertices += mesh.geometry.index.count;
                } else {
                    this.m_numVertices += mesh.geometry.getAttribute("position").count / 3;
                }
            }
            if (mesh.geometry instanceof THREE.Geometry) {
                this.m_numVertices = mesh.geometry.vertices.length;
            }
        });
    }

    /**
     * Missing Typedoc
     */
    protected preparePois(decodedTile: DecodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            this.mapView.poiManager.addPois(this, decodedTile);
        }
    }

    private getMaterialsCount() {
        let num = 0;
        this.objects.forEach((rootObject: TileObject & DisposableObject) => {
            if (rootObject.material) {
                if (Array.isArray(rootObject.material)) {
                    num += rootObject.material.length;
                } else {
                    num += 1;
                }
            }
        });
        return num;
    }
}
