/*
 * Copyright (C) 2017-2018 HERE Global B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/**
 * Data Service APIs
 * This covers all public APIs for the Data Service.
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { RequestBuilder, RequestOptions, UrlBuilder } from "./RequestBuilder";

export interface BatchInfo {
    /**
     * The ID of the catalog that this batch is updating.
     */
    catalogId: string;
    /**
     * The catalog version that this batch is updating.
     */
    catalogVersion: number;
    /**
     * Additional information such as why a batch failed
     */
    message?: string;
    /**
     * The current status of the batch.
     */
    status: BatchInfoStatusEnum;
    /**
     * The token that the batch initialization method generates. This token uniquely identifies the
     * batch.
     */
    token: string;
    /**
     * Catalog and layer versions that the batch is depends on.
     */
    versionDependencies?: VersionDependency[];
}

export type BatchInfoStatusEnum =
    | "INITIALIZED"
    | "FINALIZED"
    | "CANCELLED"
    | "FAILED"
    | "SUCCEEDED";
export interface BatchInfoList {
    batchInfoList?: BatchInfo[];
}

/**
 * Describes a set of links for the multipart upload operations.
 */
export interface BlobInitResponse {
    links?: BlobstoreLinks;
}

/**
 * Describes a link for multipart upload operations.
 */
export interface BlobstoreLink {
    /**
     * `href`
     */
    href?: string;
    /**
     * `httpRequestMethod`
     */
    method?: string;
}

/**
 * Describes a set of link for checking the status, deleting and finalizing of the multipart upload.
 */
export interface BlobstoreLinks {
    /**
     * Link for finalizing the multipart upload
     */
    complete?: BlobstoreLink;
    /**
     * Link for deleting the multipart upload
     */
    delete?: BlobstoreLink;
    /**
     * Link for checking the status of the multipart upload
     */
    status?: BlobstoreLink;
}

/**
 * Describes a status of the multipart upload.
 */
export interface BlobstoreStatus {
    reason?: string;
    status?: string;
}

/**
 * Describes the catalog properties.
 */
export interface Catalog {
    /**
     * Billing tag is an optional free-form tag, which is used for grouping billing records
     * together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric ASCII
     * characters `[A-Za-z0-9]`.
     */
    billingTag?: string;
    /**
     * The owners of the catalog.
     */
    contacts?: Contacts;
    /**
     * The creation date and time.
     */
    created: string;
    /**
     * The person who created the layer.
     */
    creator?: Creator;
    /**
     * A detailed description of the catalog and what it contains. This information appears on the
     * 'Overview' tab when you open a catalog in the platform portal.
     */
    description?: string;
    /**
     * The HERE Resource Name (HRN) for the layer.
     */
    hrn: string;
    /**
     * A unique ID for the catalog.
     */
    id: string;
    /**
     * The layers in the catalog.
     */
    layers: Layer[];
    /**
     * The short name for the catalog.
     */
    name?: string;
    /**
     * Catalog provider.
     */
    provider?: string;
    /**
     * A one-sentence summary of the catalog. You can see this summary when you browse a list of
     * catalogs on the platform portal.
     */
    summary?: string;
    /**
     * Some keywords that help to find the catalog when searching in the platform portal.
     */
    tags?: string[];
    /**
     * The version number in the catalog. Should be incremented whenever you update a catalog.
     */
    version?: number;
}

/**
 * Describes the detailed status of the failed catalog creation operation.
 */
export interface CatalogFailureStatus {
    reason?: string;
    status?: string;
}

/**
 * Describes the status of the catalog modification action.
 */
export interface CatalogPendingStatus {
    status?: string;
}

/**
 * Describes the status of the successful catalog creation operation including its href.
 */
export interface CatalogSuccessStatus {
    item?: StatusLink;
    /**
     * Status of the operation
     */
    status?: string;
}

/**
 * Describes the main properties of the catalog.
 */
export interface CatalogSummary {
    /**
     * The URL of the catalog. This URL consists of the base path, the HERE Resource Name (HRN) for
     * the catalog, and the catalog ID.
     */
    href?: string;
    /**
     * The HERE Resource Name (HRN) for the layer.
     */
    hrn?: string;
    /**
     * The title of the catalog.
     */
    title?: string;
    /**
     * The type of the `href`. All `href`s are currently set to `urn:olp-types:catalog`.
     */
    type?: string;
}

/**
 * List of the catalog summaries.
 */
export interface CatalogsList {
    items?: CatalogSummary[];
}

/**
 * Contains a list of catalogs user has access to.
 */
export interface CatalogsListResult {
    results?: CatalogsList;
}

/**
 * Contact details for the owners of resources such as catalogs.
 */
export interface Contacts {
    email?: string[];
}

/**
 * The geographic area that this layer covers.
 */
export interface Coverage {
    /**
     * A list of short codes for countries and regions, such as `'DE'` and `'PL'`.
     */
    adminAreas?: string[];
}

export interface CreateBatchRequest {
    /**
     * The version of the catalog that your batch operation is updating. You can't update a catalog
     * version other than the latest version. If this value doesn't match the latest version number
     * of the catalog, the request will fail.
     */
    catalogVersion: number;
    /**
     * Any catalogs and versions that the batch operation depends on.
     */
    versionDependencies?: VersionDependency[];
}

/**
 * Describes the configuration of the catalog including its layer definitions.
 */
export interface CreateCatalog {
    /**
     * Billing tag is an optional free-form tag, which is used for grouping billing records
     * together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric ASCII
     * characters `[A-Za-z0-9]`.
     */
    billingTag?: string;
    /**
     * Contact details for the owners of resources such as catalogs.
     */
    contacts?: Contacts;
    /**
     * A detailed description of the catalog and what it contains. This information appears on the
     * 'Overview' tab when you open a catalog in the platform portal.
     */
    description?: string;
    /**
     * This ID should be unique to one environment. You can use the same ID again in another context
     * such as a production environment. This ID forms part of the HERE Resource Name (HRN) for the
     * catalog.
     */
    id: string;
    /**
     * The layers in the catalog.
     */
    layers: CreateLayer[];
    /**
     * The short name for the catalog.
     */
    name?: string;
    /**
     * A one-sentence summary of the catalog. You can see this summary when you browse a list of
     * catalogs on the platform portal.
     */
    summary?: string;
    /**
     * Some keywords that help to find the catalog when searching in the platform portal.
     */
    tags?: string[];
}

/**
 * Describes properties of a catalog layer.
 */
export interface CreateLayer {
    /**
     * Identifies whether the data is compressed.
     */
    contentEncoding?: CreateLayerContentEncodingEnum;
    contentType?: string;
    coverage?: Coverage;
    description?: string;
    id: string;
    layerType: CreateLayerLayerTypeEnum;
    name?: string;
    partitioningScheme: CreateLayerPartitioningSchemeEnum;
    schema?: Schema;
    streamProperties?: StreamProperties;
    summary?: string;
    tags?: string[];
    ttlHours?: number;
    volume?: Volume;
}

export type CreateLayerContentEncodingEnum = "gzip";
export type CreateLayerLayerTypeEnum = "versioned" | "volatile" | "stream";
export type CreateLayerPartitioningSchemeEnum = "generic" | "heretile";
export interface Creator {
    /**
     * The unique ID of user or application that initially created the catalog.
     */
    id?: string;
}

/**
 * An HTTP Error message that the service provides when there is a problem with request.
 */
export interface ErrorMessage {
    /**
     * An error code that pertains to a specific error.
     */
    code?: string;
    /**
     * A set of validation error messages.
     */
    errors?: ValidationErrorMessage[];
    /**
     * A message that describes the cause of the error.
     */
    message?: string;
    /**
     * The HTTP status code of the error response.
     */
    status?: number;
}

export interface Index {
    /**
     * Result of the index resource call. For each parent tile, one element with the respective
     * parent-quad data is contained in the array.
     */
    parentQuads: ParentQuad[];
    /**
     * Result of the index resource call. For each tile that contains data in the requested quadkey,
     * one element with the respective sub-quad data is contained in the array.
     */
    subQuads: SubQuad[];
}

/**
 * Describes the catalog layer properties.
 */
export interface Layer {
    /**
     * Billing tag is an optional free-form tag, which is used for grouping billing records
     * together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric ASCII
     * characters `[A-Za-z0-9]`.
     */
    billingTag?: string;
    /**
     * Identifies whether the data is compressed.
     */
    contentEncoding?: LayerContentEncodingEnum;
    /**
     * The mime type of the data is stored in this layer.
     */
    contentType?: string;
    /**
     * The geographic areas that this layer covers, grouped by admin areas.
     */
    coverage?: Coverage;
    /**
     * The person who created this layer.
     */
    creator?: Creator;
    /**
     * A detailed description of the layer and what it contains. This information appears on the
     * 'Overview' tab when you open a layer in the platform portal.
     */
    description?: string;
    /**
     * The HERE Resource Name (HRN) of the layer.
     */
    hrn: string;
    /**
     * This ID should be unique to one environment. You can use the same ID again in another context
     * such as a production environment. This ID forms part of the HERE Resource Name (HRN) for the
     * layer.
     */
    id: string;
    /**
     * The type of data availability that this layer provides.
     */
    layerType: LayerLayerTypeEnum;
    /**
     * A descriptive name for the layer.
     */
    name?: string;
    /**
     * The name of the partitioning scheme for this layer.
     */
    partitioningScheme: LayerPartitioningSchemeEnum;
    /**
     * The layer provider.
     */
    provider?: string;
    /**
     * The HRN of the data schema for this layer.
     */
    schema?: Schema;
    /**
     * Properties that define the scale of the streaming service required for this layer.
     */
    streamProperties?: StreamProperties;
    /**
     * A one-sentence summary of the layer. You can see this summary when you browse a list of
     * layers on the platform portal.
     */
    summary?: string;
    /**
     * Some keywords that help to find the catalog when searching in the platform portal.
     */
    tags?: string[];
    /**
     * The expiry time for data in this layer. Data is automatically removed after the specified
     * hours have elapsed.
     */
    ttlHours?: number;
    /**
     * Properties that describe the volume where the data is physically stored.
     */
    volume?: Volume;
}

export type LayerContentEncodingEnum = "gzip";
export type LayerLayerTypeEnum = "versioned" | "volatile" | "stream";
export type LayerPartitioningSchemeEnum = "generic" | "heretile";
/**
 * Describes catalog layer version.
 */
export interface LayerVersion {
    /**
     * Layer ID
     */
    layer: string;
    /**
     * Version of the layer
     */
    version: number;
}

/**
 * Describes the list of the layer versions for a given catalog version.
 */
export interface LayerVersions {
    /**
     * List of layer versions
     */
    layerVersions: LayerVersion[];
    /**
     * Catalog version
     */
    version: number;
}

export interface MultipartCompletePart {
    etag?: string;
    number?: number;
}

export interface MultipartCompleteRequest {
    parts?: MultipartCompletePart[];
}

export interface MultipartStatus {
    /**
     * Details on the progress of the multi-part commit.
     */
    message: string;
    /**
     * The number of parts received by the Data API.
     */
    partsReceived: number;
    /**
     * The status of the multi-part commit.
     */
    status: string;
    /**
     * The batch token, which is issued by the initialize batch method. This token uniquely
     * identifies the batch.
     */
    token: string;
}

export interface MultipartUploadMetadata {
    contentEncoding?: string;
    contentType?: string;
}

export interface ParentQuad {
    /**
     * Optional value for the additional metadata specified by the publisher
     */
    additionalMetadata?: string;
    /**
     * The checksum field is optional. The response only includes this information if you specify
     * the checksum in the request (using the `additionalFields` query parameter) and if the request
     * for the commit of the partition specifies a checksum. You need to use the 'sha1' checksum of
     * the data content if you want the data comparison to work for this catalog. The maximum length
     * of the `checksum` field is 128 characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the compressed partition data in bytes. Compressed size of the
     * data when using Blobstore in the datastore-client with compression enabled to commit to Data
     * Service. The response only includes this information if you specify the `compressedDataSize`
     * field in the request, and if the request for the commit of the partition specifies a
     * `compressedDataSize`.
     */
    compressedDataSize?: number;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layer’s dataUrl. The
     * combination of dataURL + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle: string;
    /**
     * Optional value for the size of the partition data in bytes. Uncompressed size of the data
     * when using Blobstore in the datastore-client with compression enabled or disabled to commit
     * to Data Service. The response only includes this information if you specify the `dataSize`
     * field in the request, and if the request for the commit of the partition specifies
     * `dataSize`.
     */
    dataSize?: number;
    /**
     * The id of the tile
     */
    partition: string;
    /**
     * Version of the catalog when this partition was first published
     */
    version: number;
}

/**
 * Describes the partition object which is unique within a layer.
 */
export interface Partition {
    /**
     * The checksum of the partition. It's only provided to API calls that explicitly request a
     * checksum and only matches partitions that have a checksum defined. You can request partitions
     * with a specific checksum by using the `additionalFields` query parameter. If you need to
     * compare data sets for this catalog, set this field to match the SHA-1 checksum of the
     * corresponding data blob. The maximum length of the `checksum` field is 128 characters.
     */
    checksum?: string;
    /**
     * Indicates the compressed size of the partition data in bytes when the data compression is
     * enabled. It's only provided to API calls that explicitly request the compressed data size and
     * only matches partitions that have a compressed data size defined. You can request partitions
     * with a specific compressed data size by using the `additionalFields` query parameter.
     */
    compressedDataSize?: number;
    /**
     * You use the data handle when retrieving the data that relates to this partition. The data
     * handle identifies a specific blob so that you can request the blob's contents with the
     * Blobstore API. When requesting data from the Blobstore API, you must specify the catalog ID,
     * layer ID, and the `dataHandle`.
     */
    dataHandle?: string;
    /**
     * Indicates the uncompressed size of the partition data in bytes. It's only provided to API
     * calls that explicitly request the data size and only matches partitions that have a data size
     * defined. You can request partitions with a specific data size by using the `additionalFields`
     * query parameter.
     */
    dataSize?: number;
    /**
     * The unique ID of the parent layer for this partition. The layer field cannot be empty. The
     * maximum length is 50 characters.
     */
    layer: string;
    /**
     * The partition key. This is a unique key for a partition within a layer. If the layer's
     * partitioning scheme is set to 'heretile', the partition key is equivalent to the tile key.
     * The partition key cannot be empty. The maximum length of the partition key is 500 characters.
     */
    partition: string;
    /**
     * A partition can contain an embedded data object or a reference to a data blob that is stored
     * on another volume. The `partitionType` allows a client to handle scenarios where a partition
     * contains data handles that point to empty data blobs. For partitions provided by the Metadata
     * API, the `partitionType` is always 'blobstore'. For stream layers, the `partitionType` can be
     * a mixture of `'blobstore'` and `'embedded'`.
     */
    partitionType?: PartitionPartitionTypeEnum;
    /**
     * For active partitions, the version of the catalog when this partition was last changed. For
     * deleted partitions, either the version when it was deleted or the version of the first
     * snapshot after it was deleted.
     */
    version: number;
}

export type PartitionPartitionTypeEnum = "embedded" | "reference";
/**
 * Describes a list of partitions for a given layer and layer version.
 */
export interface Partitions {
    partitions: Partition[];
}

export interface Publication {
    /**
     * The batch token that the batch initialization method generates. If you're publishing a single
     * publication, you can leave this field empty.
     */
    batchToken?: string;
    /**
     * Indexes provide an efficient way to search for partitions in catalogs. Index can be submitted
     * to the Data Query service as part of a query request. For queries to return correct results,
     * the index names used in requests must match the names that are used in layers. An index can
     * specify a date range or a quadkey as search criteria.
     */
    indexes?: PublishIndex[];
    /**
     * The publish partition object that's available for consumption.
     */
    publishPartition: PublishPartition;
}

export interface Publications {
    /**
     * A list of publication objects. A publication is a wrapper that contains a partition and
     * information on how to process it.
     */
    publications: Publication[];
}

export interface PublishIndex {
    /**
     * The end date, which is specified as the number of seconds since the Unix epoch. When you
     * specify an end date and a start date, the index query becomes a date range rather that a
     * single data point.
     */
    endDate?: number;
    /**
     * The name of the index. This must align with an index that has been configured on the layer
     * via the DS Config Service. Indexes can be used to query for data via the Query Service.
     */
    name: string;
    /**
     * If the index type is a quadkey index, this must be specified as the . This indicates that
     * this object represents a time window based on the date ranges.
     */
    quadKey?: number;
    /**
     * The start date, which is specified as the number of seconds since the Unix epoch. When you
     * specify an end date and a start date, the index query becomes a date range rather that a
     * single data point.
     */
    startDate?: number;
}

export interface PublishPartition {
    /**
     * Checksum of the payload.
     */
    checksum?: string;
    /**
     * The compressed size of the payload in bytes.
     */
    compressedDataSize?: number;
    /**
     * The bytes to be stored for this partition. This is only used for Stream layers. Note that the
     * overall size of a Publish Partition must be under 1MB. This should not be used if the
     * `dataHandle` attribute is populated.
     */
    data?: string;
    /**
     * A reference to an object which has been placed into Blobstore. Should not be used if the
     * `data` attribute is populated.
     */
    dataHandle?: string;
    /**
     * The uncompressed size of the payload in bytes.
     */
    dataSize?: number;
    /**
     * The partition key. This is a unique key for a partition within a layer. If the layer's
     * partitioning scheme is set to 'heretile', the partition key is equivalent to the tile key.
     * The partition key cannot be empty. The maximum length of the partition key is 500 characters.
     */
    partition: string;
}

export interface ResponseFail {
    /**
     * A description of the problem.
     */
    errorMessage?: string;
    /**
     * A unique ID for the message. This can be a user-defined trace ID included in the request. If
     * a trace ID was not included in the request, one is generated during ingestion and included in
     * the response. You can use this ID to track your request and identify the message in the
     * catalog.
     */
    traceID?: string;
}

export interface ResponseOkSingle {
    /**
     * A unique ID for the message. This can be a user-defined trace ID included in the request. If
     * a trace ID was not included in the request, one is generated during ingestion and included in
     * the response. You can use this ID to track your request and identify the message in the
     * catalog.
     */
    traceID?: string;
}

/**
 * Describes an HRN for the layer schema.
 */
export interface Schema {
    hrn?: string;
}

/**
 * Describes the status and href of the created resource such as a catalog.
 */
export interface StatusLink {
    /**
     * Href of the created catalog.
     */
    href?: string;
    /**
     * Title of the created catalog.
     */
    title?: string;
    /**
     * Type of the href.
     */
    type?: string;
}

/**
 * Properties that define the scale of the required streaming service.
 */
export interface StreamProperties {
    /**
     * Expected throughput for incoming data expressed in megabytes per second. This data is used by
     * the platform to create an appropriately scaled streaming service.
     */
    dataInThroughputMbps?: number;
    /**
     * Expected throughput for outgoing data expressed in megabytes per second. This data is used by
     * the platform to create an appropriately scaled streaming service.
     */
    dataOutThroughputMbps?: number;
}

export interface SubQuad {
    /**
     * Optional value for the additional meta-data specified by the publisher.
     */
    additionalMetadata?: string;
    /**
     * The checksum field is optional. The response only includes this information if you specify
     * checksum in the request (using `additionalFields` query parameter), and if the request for
     * the commit of the partition a checksum was provided during commit of the partition. It should
     * be set to the sha1 checksum of the data content if the data comparison needs to work for this
     * catalog. The maximum length of `checksum` field is 128 characters.
     */
    checksum?: string;
    /**
     * Optional value for the size of the compressed partition data in bytes. Compressed size of the
     * data when using Blobstore in the datastore-client with compression enabled to commit to Data
     * Service.  The response only includes this information if you specify the `compressedDataSize`
     * field in the request, and if the request for the commit of the partition specifies
     * `compressedDataSize`.
     */
    compressedDataSize?: number;
    /**
     * The `dataHandle` uniquely identifies a tile within the scope of the layer’s dataUrl. The
     * combination of dataURL + `dataHandle` should be a fully qualified URL. To store data in the
     * `dataHandle` directly the 'data' URL scheme (RFC 2397) should be used. The `dataHandle` must
     * not contain any characters that are not part of the reserved and unreserved set as defined in
     * RFC3986. Empty value of this field is allowed. If the `dataHandle` is empty or omitted, it
     * means that the partition is deleted. To delete a partition in the new version, the
     * `dataHandle` should be omitted or empty string provided. The maximum length of `dataHandle`
     * is 1024 characters.
     */
    dataHandle: string;
    /**
     * Optional value for the size of the partition data in bytes. Uncompressed size of the data
     * when using Blobstore in the datastore-client with compression enabled or disabled to commit
     * to Data Service. The response only includes this information if you specify the `dataSize`
     * field in the requested, and if the request for the commit of the partition specifies
     * `dataSize`.
     */
    dataSize?: number;
    /**
     * Variable length string defining the child of the passed in the quadkey tile. Depending on the
     * partitioning scheme of the layer, either a 'quadtree' (deprecated) or a 'heretile' formatted
     * id from the sub quad will be returned. When the quadkey is referenced in the response (for
     * example, when depth is 0), subQuadKey is an empty string for 'quadtree' partitioning, and '1'
     * for 'heretile' partitioning.
     */
    subQuadKey: string;
    /**
     * Version of the catalog when this partition was first published.
     */
    version: number;
}

export interface UpdateCatalog {
    contacts?: Contacts;
    description?: string;
    id: string;
    layers: CreateLayer[];
    name?: string;
    summary?: string;
    tags?: string[];
    version?: number;
}

/**
 * HTTP Error message thrown by the service.
 */
export interface ValidationErrorMessage {
    /**
     * Error code that pertains to a specific error.
     */
    code?: string;
    /**
     * The field of the object that is invalid. The field follows RFC 6901 JSON Pointer (see:
     * https://tools.ietf.org/html/rfc6901).
     */
    field?: string;
    /**
     * The value that is invalid that was sent.
     */
    invalidValue?: any;
    /**
     * This is the message for the error.
     */
    message?: string;
    /**
     * Duplicate of the HTTP status that is returned.
     */
    status?: number;
}

/**
 * Describes the properties of the version dependencies.
 */
export interface VersionDependency {
    /**
     * Indicates the type of data dependency. If this value is set to false, this dependency is an
     * indirect dependency. This means that data from this catalog was not directly used by a data
     * processing filter to update the current version of the catalog. Instead, the data was only
     * used by upstream filters to generate the input data for a data processing filter.
     */
    direct: boolean;
    /**
     * The HERE Resource Name (HRN) of the catalog that the batch commit depends on.
     */
    hrn: string;
    /**
     * The version of the catalog of the catalog that the batch commit depends on.
     */
    version: number;
}

/**
 * Describes properties for the catalog version.
 */
export interface VersionInfo {
    /**
     * A list of the catalog dependencies.
     */
    dependencies: VersionDependency[];
    /**
     * A map of the layers in the catalog and their partition counts. The map is expressed in key
     * value pairs.
     */
    partitionCounts?: { [key: string]: number };
    /**
     * The data validity expressed in hours. After these hours have elapsed, the data is purged.
     */
    timeToLive: number;
    /**
     * Timestamp that indicates when the version was created.
     */
    timestamp: number;
    /**
     * The version number of the catalog.
     */
    version: number;
}

/**
 * Describes the list of version information for a catalog.
 */
export interface VersionInfos {
    versions: VersionInfo[];
}

export interface VersionResponse {
    version: number;
}

/**
 * Describes a catalog volume to use for storing the layer's data content.
 */
export interface Volume {
    properties?: VolumeProperties;
    volumeType: VolumeVolumeTypeEnum;
}

export type VolumeVolumeTypeEnum = "durable" | "volatile";
/**
 * Describes the properties of the catalog volume.
 */
export interface VolumeProperties {
    /**
     * `failOnWrite`
     */
    maxMemoryPolicy?: VolumePropertiesMaxMemoryPolicyEnum;
    /**
     * `small`
     */
    packageType?: VolumePropertiesPackageTypeEnum;
}

export type VolumePropertiesMaxMemoryPolicyEnum = "failOnWrite";
export type VolumePropertiesPackageTypeEnum = "small" | "medium" | "large";

/* ===================================================================
 * BlobstoreapiApi
*/

/**
 * Check if this data handle exists in Blobstore.
 *
 * @summary Check if a data handle exists.
 * @param catalogId The ID of the parent catalog for this blob.
 * @param layerId The ID of the layer that the blob belongs to. The layer must belong to the catalog
 * referenced by the `catalogId` parameter.
 * @param dataHandle The data handle identifies a specific blob so that you can get that blob's
 * contents.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function checkHandleExistsUsingHEAD(
    builder: RequestBuilder,
    params: { catalogId: string; layerId: string; dataHandle: string; billingTag?: string }
): Promise<string> {
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "HEAD",
        headers
    };

    return builder.request<string>(urlBuilder, options);
}

/**
 * Complete the batch.
 *
 * @summary Completes the batch.
 * @param catalogId The ID of the catalog that the data blob part belongs to. Content of this
 * parameter must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob part belongs to. Content of this parameter
 * must refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which the part
 * belongs to.
 * @param multiPartToken The identifier of the multipart upload (token). Content of this parameter
 * must refer to a valid nand started multipart upload.
 * @param parts parts.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function completeMultipartUsingPUT(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        multiPartToken: string;
        parts?: MultipartCompleteRequest;
        billingTag?: string;
    }
): Promise<any> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}/multiparts/{multiPartToken}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle))
        .replace("{multiPartToken}", UrlBuilder.toString(params.multiPartToken));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.parts !== undefined) {
        options.body = JSON.stringify(params.parts);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Cancel a multipart upload - can only occur before the multipart has been completed.
 *
 * @summary Cancel a multipart upload.
 * @param catalogId The ID of the catalog that the data blob part belongs to. Content of this
 * parameter must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob part belongs to. Content of this parameter
 * must refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which the part
 * belongs to.
 * @param multiPartToken The identifier of the multipart upload (token). Content of this parameter
 * must refer to a valid nand started multipart upload.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function deleteMultipartUsingDELETE(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        multiPartToken: string;
        billingTag?: string;
    }
): Promise<any> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}/multiparts/{multiPartToken}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle))
        .replace("{multiPartToken}", UrlBuilder.toString(params.multiPartToken));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Deletes a data blob from the underlying storage mechanism (volume).
 *
 * @summary Deletes a data blob.
 * @param catalogId The ID of the catalog that the data blob belongs to. Content of this parameter
 * must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob belongs to. Content of this parameter must
 * refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which contents
 * will be deleted.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function deleteObjectUsingDELETE(
    builder: RequestBuilder,
    params: { catalogId: string; layerId: string; dataHandle: string; billingTag?: string }
): Promise<string> {
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<string>(urlBuilder, options);
}

/**
 * Retrieves a blob from storage.
 *
 * @summary Gets a blob.
 * @param catalogId The ID of the parent catalog for this blob.
 * @param layerId The ID of the parent layer for this blob. The layer must belong to the catalog
 * referenced by the `catalogId` parameter.
 * @param dataHandle The data handle identifies a specific blob so that you can get that blob's
 * contents.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function fetchDataUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string; layerId: string; dataHandle: string; billingTag?: string }
): Promise<string> {
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<string>(urlBuilder, options);
}

/**
 * Get multipart status.
 *
 * @summary Get the status of a multipart upload.
 * @param catalogId The ID of the catalog that the data blob part belongs to. Content of this
 * parameter must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob part belongs to. Content of this parameter
 * must refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which the part
 * belongs to.
 * @param multiPartToken The identifier of the multipart upload (token). Content of this parameter
 * must refer to a valid token which was provided when the multipart upload was initiated.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getMultipartStatusUsingGET(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        multiPartToken: string;
        billingTag?: string;
    }
): Promise<any> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}/multiparts/{multiPartToken}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle))
        .replace("{multiPartToken}", UrlBuilder.toString(params.multiPartToken));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Persists the data blob in the underlying storage mechanism (volume).
 *
 * @summary Publish the data blob.
 * @param catalogId The ID of the catalog that the data blob belongs to. Content of this parameter
 * must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob belongs to. Content of this parameter must
 * refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which contents
 * will be deleted.
 * @param file file.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function publishObjectUsingPUT(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        file: any;
        billingTag?: string;
    }
): Promise<string> {
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    options.body = UrlBuilder.stringifyQuery({
        file: params.file
    });

    return builder.request<string>(urlBuilder, options);
}

/**
 * Multipart upload is used to publish large data blobs where the data payload needs to be split
 * into multiple parts. The multipart upload start is to be followed by the individual parts upload
 * and completed with the call to the completeMultipart.
 *
 * @summary Start a multipart upload and get a token to use in part uploads.
 * @param catalogId The ID of the catalog that the data blob belongs to. Content of this parameter
 * must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob belongs to. Content of this parameter must
 * refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which contents
 * will be persisted.
 * @param body body
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function startMultipartUsingPOST(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        body?: MultipartUploadMetadata;
        billingTag?: string;
    }
): Promise<BlobInitResponse> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}/multiparts"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<BlobInitResponse>(urlBuilder, options);
}

/**
 * Upload a single part of the multipart upload for the blob data.
 *
 * @summary Upload a part.
 * @param catalogId The ID of the catalog that the data blob part belongs to. Content of this
 * parameter must refer to a valid catalog ID.
 * @param layerId The ID of the layer that the data blob part belongs to. Content of this parameter
 * must refer to a valid layer already configured in the catalog configuration.
 * @param dataHandle The data handle (ID) represents an identifier for the data blob which the part
 * belongs to.
 * @param multiPartToken The identifier of the multipart upload (token). Content of this parameter
 * must refer to a valid nand started multipart upload.
 * @param partNumber The number of the part for the multipart upload. The numbers of the upload
 * parts must start from 1 and be consecutive.
 * @param file file
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function uploadPartUsingPOST(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        dataHandle: string;
        multiPartToken: string;
        partNumber: string;
        file: any;
        billingTag?: string;
    }
): Promise<any> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/blobstore/v1/catalogs/{catalogId}/layers/{layerId}/data/{dataHandle}/multiparts/{multiPartToken}/parts"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{dataHandle}", UrlBuilder.toString(params.dataHandle))
        .replace("{multiPartToken}", UrlBuilder.toString(params.multiPartToken));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("partNumber", params.partNumber);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    options.body = UrlBuilder.stringifyQuery({
        file: params.file
    });

    return builder.request<any>(urlBuilder, options);
}

/* ===================================================================
 * ConfigapiApi
*/

/**
 * Update any descriptive and structural information in the catalog. To update a catalog, you send a
 * new version of your catalog configuration with the updated data and any required fields.
 *
 * @summary Updates a catalog.
 * @param catalogHrn The HERE Resource Name (HRN) of the catalog.
 * @param catalog A catalog object that contains metadata and layer definitions.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function catalogUsingPUT(
    builder: RequestBuilder,
    params: { catalogHrn: string; catalog: UpdateCatalog; billingTag?: string }
): Promise<string> {
    const baseUrl = "/config/v1/catalogs/{catalogHrn}".replace(
        "{catalogHrn}",
        UrlBuilder.toString(params.catalogHrn)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.catalog !== undefined) {
        options.body = JSON.stringify(params.catalog);
    }

    return builder.request<string>(urlBuilder, options);
}

/**
 * Create a new catalog with the specified layers. The create catalog operation runs asynchronously.
 * Once you've submitted the catalog for creation, you'll receive a randomly generated token that
 * you can use to monitor the status of the operation.
 *
 * @summary Creates a catalog.
 * @param catalog A catalog object that contains metadata and layer definitions.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function createCatalogUsingPOST(
    builder: RequestBuilder,
    params: { catalog: CreateCatalog; billingTag?: string }
): Promise<any> {
    const baseUrl = "/config/v1/catalogs";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.catalog !== undefined) {
        options.body = JSON.stringify(params.catalog);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Deletes a catalog and any layers within that catalog.
 *
 * @summary Deletes a catalog.
 * @param catalogHrn The HERE Resource Name (HRN) of the catalog.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function deleteCatalogUsingDELETE(
    builder: RequestBuilder,
    params: { catalogHrn: string; billingTag?: string }
): Promise<any> {
    const baseUrl = "/config/v1/catalogs/{catalogHrn}".replace(
        "{catalogHrn}",
        UrlBuilder.toString(params.catalogHrn)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Takes the randomly generated token that you receive when you submit a catalog for creation. You
 * can use it to monitor the status of your request.
 *
 * @summary Gets the status of a create request.
 * @param token The token of catalog creation task.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function getCatalogStatusUsingGET(
    builder: RequestBuilder,
    params: { token: string; billingTag?: string }
): Promise<any> {
    const baseUrl = "/config/v1/status/{token}".replace(
        "{token}",
        UrlBuilder.toString(params.token)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Gets the full catalog configuration for the requested catalog. The catalog configuration contains
 * descriptive and structural information such as layer definitions and layer types.
 *
 * @summary Gets the details of a catalog.
 * @param catalogHrn The HERE Resource Name (HRN) of the catalog.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function getCatalogUsingGET(
    builder: RequestBuilder,
    params: { catalogHrn: string; billingTag?: string }
): Promise<Catalog> {
    const baseUrl = "/config/v1/catalogs/{catalogHrn}".replace(
        "{catalogHrn}",
        UrlBuilder.toString(params.catalogHrn)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Catalog>(urlBuilder, options);
}

/**
 * Lists all catalogs that your account has access to. To get access to a catalog, your
 * administrator must associate it in your HERE platform account. By default, the list provides
 * summary data for each catalog such as the title, configuration URL, and resource type.
 *
 * @summary Gets a list of all catalogs.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alphanumeric
 * ASCII characters `[A-Za-z0-9]`.
 */
export function getCatalogsUsingGET(
    builder: RequestBuilder,
    params: { billingTag?: string }
): Promise<CatalogsListResult> {
    const baseUrl = "/config/v1/catalogs";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<CatalogsListResult>(urlBuilder, options);
}

/* ===================================================================
 * IngestionapiApi
*/

/**
 * Sends streaming data, such as data from sensors, to a specified catalog and layer in the Open
 * Location Platform.
 *
 * @summary Sends sensor data to a catalog and layer.
 * @param catalogId The ID of the catalog where you want the data ingested.
 * @param layerId The ID of the layer where you want the data ingested.
 * @param data A byte array of data to send to the Open Location Platform for ingestion.
 * @param xHEREChecksum A SHA-256 hash you can provide for validation against the calculated value
 * on the request body hash. This verifies the integrity of your request and prevents modification
 * by a third party. A SHA-256 hash consists of 256 bits or 64 chars.
 * @param xHERETraceId A unique message ID, such as a UUID. This can be included in the request if
 * you want to use an ID that you define. If you do not include an ID, one will be generated during
 * ingestion and included in the response. You can use this ID to track your request and identify
 * the message in the catalog.
 */
export function ingestViaPublishAPIUsingPOST(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        data: string;
        xHEREChecksum?: string;
        xHERETraceId?: string;
    }
): Promise<ResponseOkSingle> {
    const baseUrl = "/ingest/v1/catalog/{catalogId}/layer/{layerId}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.data !== undefined) {
        options.body = JSON.stringify(params.data);
    }
    if (params.xHEREChecksum !== undefined) {
        headers["X-HERE-Checksum"] = params.xHEREChecksum as string;
    }
    if (params.xHERETraceId !== undefined) {
        headers["X-HERE-TraceId"] = params.xHERETraceId as string;
    }

    return builder.request<ResponseOkSingle>(urlBuilder, options);
}

/* ===================================================================
 * MetadataapiApi
*/

/**
 * Gets the metadata changes for a given partition.
 *
 * @summary Gets partition history.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param layerId Unique layer ID. Content of this parameter must refer to a valid layer ID.
 * @param partition Partition ID.
 * @param version Starting version of the catalog for the changes history.
 * @param limit Limit - indicates the max number of returned entries.
 * @param direction Direction - indicates if the changes are before or after the given version.
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getChangeHistoryUsingGET(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        partition: string;
        version: number;
        limit: number;
        direction?: string;
        additionalFields?: string[];
        billingTag?: string;
    }
): Promise<Partitions> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/layers/{layerId}/partitions/{partition}/changeHistory"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{partition}", UrlBuilder.toString(params.partition));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("direction", params.direction);
    urlBuilder.appendQuery("limit", params.limit);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * Gets the partition changes for a given version range of the catalog. The range is expressed as a
 * start and end version.
 *
 * @summary Gets changes for version range.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param layerId Unique layer ID. Content of this parameter must refer to a valid layer ID.
 * @param startVersion Start version for the catalog.
 * @param endVersion End version of the catalog (inclusive)
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`.
 * @param range Range - specifies range of the response (start/end). Can be used for paging
 * purposes. Example range&#x3D;bytes&#x3D;10-
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getChangesUsingGET(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        startVersion: number;
        endVersion: number;
        additionalFields?: string[];
        range?: string;
        billingTag?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/layers/{layerId}/changes"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * Gets the partitions metadata. When no explicit filters are specified in query parameters, this
 * call will internally scan the entire catalog. If the layer specified in the request does not
 * exist, an error is returned.
 *
 * @summary Gets partitions.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param layerId Unique layer ID. Content of this parameter must refer to a valid layer ID.
 * @param version Catalog Version.
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`.
 * @param range Range - specifies range of the response (start/end). Can be used for paging
 * purposes. Example range&#x3D;bytes&#x3D;10-
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getPartitionsUsingGET(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        version: number;
        additionalFields?: string[];
        range?: string;
        billingTag?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/layers/{layerId}/partitions"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * Returns latest version for the given catalog. 404 will be returned if the catalog doesn't contain
 * any versions.
 *
 * @summary Gets the latest catalog version.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param startVersion Start version.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function latestVersionUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string; startVersion: number; billingTag?: string }
): Promise<VersionResponse> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/versions/latest".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<VersionResponse>(urlBuilder, options);
}

/**
 * Returns information about the catalog version. It will return an error if the catalog does not
 * have any versions or if the version passed in the query parameter does not exist. Additionally
 * layers without committed partitions will be omitted.
 *
 * @summary Gets layer versions for catalog version.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param version Catalog Version.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function layerVersionsForCatalogUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string; version: number; billingTag?: string }
): Promise<LayerVersions> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/layerVersions".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<LayerVersions>(urlBuilder, options);
}

/**
 * Returns information about specific data version(s). 404 will be returned if the catalog doesn't
 * contain any versions.
 *
 * @summary Gets catalog versions.
 * @param catalogId Unique catalog ID. Content of this parameter must refer to a valid catalog ID.
 * @param startVersion Start Version (inclusive). By convention -1 indicates the virtual initial
 * version before the first publication which will have version 0.
 * @param endVersion End Version (inclusive).
 * @param billingTag Billing tag is an optional free-form tag which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function listVersionsUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string; startVersion: number; endVersion: number; billingTag?: string }
): Promise<VersionInfos> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/versions".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<VersionInfos>(urlBuilder, options);
}

/**
 * Returns minimum version for the given catalog. 404 will be returned if the catalog doesn't
 * contain any versions.
 *
 * @summary Gets the earliest catalog version.
 * @param catalogId Unique catalog ID.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function minimumVersionUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string; billingTag?: string }
): Promise<VersionResponse> {
    const baseUrl = "/metadata/v1/catalogs/{catalogId}/versions/minimum".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<VersionResponse>(urlBuilder, options);
}

/* ===================================================================
 * PublishapiApi
*/

/**
 * Cancels an active batch and ensures that the submitted publications are discarded. If the batch
 * has already been finalized, you can't invoke this call.
 *
 * @summary Cancels the batch.
 * @param batchToken Batch token, which is issued by the initialize batch method.
 * @param catalogId Unique ID of the catalog.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function deleteBatchUsingDELETE(
    builder: RequestBuilder,
    params: { batchToken: string; catalogId: string; billingTag?: string }
): Promise<any> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/batches/{batchToken}"
        .replace("{batchToken}", UrlBuilder.toString(params.batchToken))
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Finalizes the batch and releases the data for processing and consumption. You can't cancel a
 * batch commit after invoking this call.
 *
 * @summary Finalizes a batch.
 * @param batchToken Batch token, which is issued by the initialize batch method.
 * @param catalogId Unique ID of the catalog.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function finalizeUsingPUT(
    builder: RequestBuilder,
    params: { batchToken: string; catalogId: string; billingTag?: string }
): Promise<any> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/batches/{batchToken}"
        .replace("{batchToken}", UrlBuilder.toString(params.batchToken))
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };

    return builder.request<any>(urlBuilder, options);
}

/**
 * Returns recent information about batches for a catalog.
 *
 * @summary Get batches for a catalog.
 * @param catalogId Id of catalog being published to.
 */
export function getBatchesUsingGET(
    builder: RequestBuilder,
    params: { catalogId: string }
): Promise<BatchInfoList> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/batches".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<BatchInfoList>(urlBuilder, options);
}

/**
 * Provides details of a batch including the status and number of partitions that have been
 * uploaded.
 *
 * @summary Gets the batch status.
 * @param batchToken Batch token, which is issued by the initialize batch method.
 * @param catalogId Unique ID of the catalog.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getStatusUsingGET(
    builder: RequestBuilder,
    params: { batchToken: string; catalogId: string; billingTag?: string }
): Promise<BatchInfo> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/batches/{batchToken}"
        .replace("{batchToken}", UrlBuilder.toString(params.batchToken))
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<BatchInfo>(urlBuilder, options);
}

/**
 * Allows multiple partitions to be published in a single request. Any indexes for the partition are
 * published as a key/value pair. You can publish a single partition directly or as part of a batch
 * commit. Batch commits are only suitable for small messages. To upload large objects, use the
 * single-partition method.
 *
 * @summary Publishes multiple publications.
 * @param catalogId Unique ID of the catalog.
 * @param layerId Unique ID of the layer.
 * @param publications A collection of items to be published.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function publishPartitionsUsingPOST(
    builder: RequestBuilder,
    params: { catalogId: string; layerId: string; publications: Publications; billingTag?: string }
): Promise<any> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/layers/{layerId}/publications"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.publications !== undefined) {
        options.body = JSON.stringify(params.publications);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Provides a token that you can use to group partitions and commit them to your catalog as a
 * batchCatalogs can accept only one commit at a time. You can commit multiple layers as long as
 * they all belong to one catalog version. If your catalog contains layers that are referenced by
 * other catalogs, wait until your batch commit has finished before you commit to those other
 * catalogs.
 *
 * @summary Initializes a batch.
 * @param catalogId Unique ID of the catalog.
 * @param body Catalog Version and any dependencies.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function startUsingPOST(
    builder: RequestBuilder,
    params: { catalogId: string; body: CreateBatchRequest; billingTag?: string }
): Promise<string> {
    const baseUrl = "/publish/v1/catalogs/{catalogId}/batches".replace(
        "{catalogId}",
        UrlBuilder.toString(params.catalogId)
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params.body !== undefined) {
        options.body = JSON.stringify(params.body);
    }

    return builder.request<string>(urlBuilder, options);
}

/* ===================================================================
 * QueryapiApi
*/

/**
 * Obtains the changes between two versions of a catalog. If the request does not specify a layer or
 * partition parameters, the query runs on all layers and partitions. URI size and the filter
 * defined by partition and layer parameters have the same limitations as the
 * '/query/v1/catalogs/{catalogId}/layers/{layerId}/partitions endpoint'.
 *
 * @summary Get partitions.
 * @param catalogId The ID of the catalog specified in the request. The value of this parameter must
 * refer to a valid catalog.
 * @param layerId The ID of the layer specified in the request. The value of this parameter must
 * refer to a valid layer already configured in the catalog configuration. You can specify multiple
 * layers as additional parameters.
 * @param startVersion Start version (exclusive). It has to be valid catalog version or one less
 * than minimum not deleted version.
 * @param endVersion End version (inclusive). This has to be a valid catalog version greater than
 * the startVersion
 * @param partition Partition name to use for filtering. You can specify multiple partitions by
 * using this parameter multiple times. If the request does not specify this parameter, all
 * partitions are considered.
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`,
 * `partitionType`.
 * @param range Parameter you can use to resume download of big responses from a specific byte
 * offset in case of a connection issue between client and server. This parameter needs to be
 * compliant with RFC 7233. The Data Service supports only single byte range, which should be offset
 * such as, for example, 'range&#x3D;bytes&#x3D;10-'.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getChangesUsingGET1(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        startVersion: string;
        endVersion: string;
        partition: string[];
        additionalFields?: string[];
        range?: string;
        billingTag?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/query/v1/catalogs/{catalogId}/layers/{layerId}/changes"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("startVersion", params.startVersion);
    urlBuilder.appendQuery("endVersion", params.endVersion);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);
    urlBuilder.appendQuery("partition", params.partition);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * If the query parameters do not specify explicit filters, this request searches the entire
 * catalog. If possible, explicitly request the required partitions. If the layer specified in the
 * request does not exist, the request results in an error. If a partition specified in the request
 * does not exist, the response does not include this partition. The total URI length must not
 * exceed 2000 bytes. If the request includes the partition parameter, the filter defined by the
 * 'layer' and 'partition' parameters must limit the potential number of returned partitions to less
 * than 1000. For example, specifying a filter with three (3) layers and 10 partitions is allowed
 * (potentially 30 partitions in total), while specifying a filter with 30 layers and 40 partitions
 * is not (potentially 1200 partitions in total). If the request does not specify a layer filter,
 * the size of the layer filter is the number of layers in that catalog. In other words, if the
 * catalog holds 100 layers, and you specify only a partition filter in the request, this filter
 * must specify fewer than 10 partitions. If the request includes the layer parameter but not the
 * partition parameter, there are no limitations on the number of partitions considered and the
 * response includes all partitions from matching layers.
 *
 * @summary Get metadata for the requested partitions.
 * @param catalogId The ID of the catalog specified in the request. The content of this parameter
 * must refer to a valid catalog.
 * @param layerId The ID of the layer specified in the request. The content of this parameter must
 * refer to a valid layer already configured in the catalog configuration. You can specify multiple
 * partitions by using this parameter multiple times.
 * @param version The version of the catalog against which to run the query. Must be a valid catalog
 * version.
 * @param partition Partition name to use for filtering. You can specify multiple partitions by
 * using this parameter multiple times. If the request does not specify this parameter, all
 * partitions are considered.
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`,
 * `partitionType`.
 * @param range Parameter you can use to resume download of big responses from a specific byte
 * offset in case of a connection issue between client and server. This parameter needs to be
 * compliant with RFC 7233. The Data Service supports only single byte range, which should be offset
 * as, for example, 'range&#x3D;bytes&#x3D;10-'.
 * @param billingTag Billing tag is an optional free-form tag, which is used for grouping billing
 * records together. If supplied, it must be between 4 - 16 characters, contain only alpha/numeric
 * ASCII characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in
 * future releases.
 */
export function getPartitionsUsingGET1(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        version: string;
        partition: string[];
        additionalFields?: string[];
        range?: string;
        billingTag?: string;
    }
): Promise<Partitions> {
    const baseUrl = "/query/v1/catalogs/{catalogId}/layers/{layerId}/partitions"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("version", params.version);
    urlBuilder.appendQuery("partition", params.partition);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("range", params.range);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Partitions>(urlBuilder, options);
}

/**
 * Get metadata for the requested index. Only available for layers where the partitioning scheme is
 * 'heretile'.
 *
 * @summary Get index metadata.
 * @param catalogId The ID of the catalog specified in the request. Content of this parameter must
 * refer to a valid catalog.
 * @param layerId The ID of the layer specified in the request. Content of this parameter must refer
 * to a valid layer already configured in the catalog configuration. Exactly one layer ID must be
 * provided.
 * @param version The version of the catalog against which to run the query. Must be a valid catalog
 * version.
 * @param quadKey The geometric area specified by an index in the request, represented as a HERE
 * tile
 * @param depth The recursion depth of the response. If set to 0, the response includes only data
 * for the quadkey specified in the request. In this way, depth describes the maximum length of the
 * `subQuadKeys` in the response. The maximum allowed value for the depth parameter is 4.
 * @param additionalFields Additional fields - `dataSize`, `checksum`, `compressedDataSize`.
 * @param billingTag Billing tag is an optional free-form tag, used to group billing records
 * together. If supplied, it must be between 4 - 16 characters and  contain only alphanumeric ASCII
 * characters `[A-Za-z0-9]`. Grouping billing records by billing tag will be available in a future
 * release.
 */
export function quadTreeIndexUsingGET(
    builder: RequestBuilder,
    params: {
        catalogId: string;
        layerId: string;
        version: number;
        quadKey: string;
        depth: number;
        additionalFields?: string[];
        billingTag?: string;
    }
): Promise<Index> {
    // tslint:disable-next-line:max-line-length
    const baseUrl = "/query/v1/catalogs/{catalogId}/layers/{layerId}/versions/{version}/quadkeys/{quadKey}/depths/{depth}"
        .replace("{catalogId}", UrlBuilder.toString(params.catalogId))
        .replace("{layerId}", UrlBuilder.toString(params.layerId))
        .replace("{version}", UrlBuilder.toString(params.version))
        .replace("{quadKey}", UrlBuilder.toString(params.quadKey))
        .replace("{depth}", UrlBuilder.toString(params.depth));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("additionalFields", params.additionalFields);
    urlBuilder.appendQuery("billingTag", params.billingTag);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Index>(urlBuilder, options);
}
