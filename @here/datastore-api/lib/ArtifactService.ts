/*
 * Copyright (C) 2017-2018 HERE Global B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/**
 * Artifact Service
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.20180427.2242
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { UrlBuilder, RequestBuilder, RequestOptions } from './RequestBuilder';

export interface Artifact {
    artifactId: string;
    created: Date;
    groupId: string;
    hrn: string;
    updated: Date;
    version: string;
}

export interface ArtifactFile {
    name?: string;
}

export interface DeleteArtifactResponse {
    artifact?: Artifact;
    files?: Array<string>;
}

export interface DeleteFileResponse {
    artifact?: Artifact;
    file?: string;
}

export interface DeleteSchemaResponse {
    artifacts?: Array<Artifact>;
    schema?: Schema;
}

export interface GetArtifactResponse {
    artifact?: Artifact;
    files?: Array<ArtifactFile>;
}

export interface GetSchemaResponse {
    artifacts?: Array<Artifact>;
    schema?: Schema;
    variants?: Array<Variant>;
}

export interface InputStream {
}

export interface ListSchemasResponse {
    items?: Array<Schema>;
    next?: string;
    page?: PagedQuery;
}

export interface ModelFile {
    absolute?: boolean;
    absoluteFile?: any;
    absolutePath?: string;
    canonicalFile?: any;
    canonicalPath?: string;
    directory?: boolean;
    file?: boolean;
    freeSpace?: number;
    hidden?: boolean;
    name?: string;
    parent?: string;
    parentFile?: any;
    path?: string;
    totalSpace?: number;
    usableSpace?: number;
}

export interface PagedQuery {
    from?: string;
    limit?: number;
    order: PagedQueryOrderEnum;
    sort: string;
}

export type PagedQueryOrderEnum = "ASC" | "DESC";
export interface Principal {
    type: PrincipalTypeEnum;
    token: string;
}

export type PrincipalTypeEnum = "User" | "App" | "Group";
export interface RegisterArtifactRequest {
    userId?: string;
}

export interface RegisterArtifactResponse {
    artifactId?: string;
    created?: boolean;
    groupId?: string;
    hrnPrefix?: string;
}

export interface Resource {
    description?: string;
    file?: any;
    filename?: string;
    inputStream?: InputStream;
    open?: boolean;
    readable?: boolean;
    uri?: URI;
    url?: URL;
}

export interface Schema {
    artifactId: string;
    created: Date;
    groupId: string;
    hrn: string;
    name: string;
    summary?: string;
    updated: Date;
    version: string;
}

export interface URI {
    absolute?: boolean;
    authority?: string;
    fragment?: string;
    host?: string;
    opaque?: boolean;
    path?: string;
    port?: number;
    query?: string;
    rawAuthority?: string;
    rawFragment?: string;
    rawPath?: string;
    rawQuery?: string;
    rawSchemeSpecificPart?: string;
    rawUserInfo?: string;
    scheme?: string;
    schemeSpecificPart?: string;
    userInfo?: string;
}

export interface URL {
    authority?: string;
    content?: any;
    defaultPort?: number;
    file?: string;
    host?: string;
    path?: string;
    port?: number;
    protocol?: string;
    query?: string;
    ref?: string;
    userInfo?: string;
}

export interface UpdatePermissionRequest {
    principal: Principal;
    permissions: Array<UpdatePermissionRequestPermissionsEnum>;
    permitted?: boolean;
}

export type UpdatePermissionRequestPermissionsEnum = "READ" | "MODIFY" | "SHARE";
export interface UpdatePermissionResponse {
    permissions?: Array<UpdatePermissionResponsePermissionsEnum>;
    permitted?: boolean;
    principal?: Principal;
}

export type UpdatePermissionResponsePermissionsEnum = "READ" | "MODIFY" | "SHARE";
export interface Variant {
    id: string;
    url: string;
}



/* ===================================================================
 * ArtifactsApi
*/


/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete a specific artifact
 * @param artifactHrn artifactHrn
 */
export function deleteArtifactUsingDELETE(builder: RequestBuilder, params: {  artifactHrn: string; }): Promise<DeleteArtifactResponse> {
    const baseUrl = "/v1/artifact/{artifactHrn}"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteArtifactResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete a specific artifact file
 * @param artifactHrn artifactHrn
 */
export function deleteFileUsingDELETE(builder: RequestBuilder, params: {  artifactHrn: string; }): Promise<DeleteFileResponse> {
    const baseUrl = "/v1/artifact/{artifactHrn}/**"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteFileResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Retrieve a specific artifact file
 * @param artifactHrn artifactHrn
 */
export function getArtifactFileUsingGET(builder: RequestBuilder, params: {  artifactHrn: string; }): Promise<InputStream> {
    const baseUrl = "/v1/artifact/{artifactHrn}/**"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<InputStream>(urlBuilder, options);
}

/**
 * 
 *
 * @summary getArtifact
 * @param artifactHrn artifactHrn
 */
export function getArtifactUsingGET(builder: RequestBuilder, params: {  artifactHrn: string; }): Promise<GetArtifactResponse> {
    const baseUrl = "/v1/artifact/{artifactHrn}"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GetArtifactResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Create or update a specific artifact
 * @param artifactHrn artifactHrn
 * @param authorizationClaims authorization-claims
 */
export function putArtifactFileUsingPUT(builder: RequestBuilder, params: {  artifactHrn: string; authorizationClaims?: string; }): Promise<any> {
    const baseUrl = "/v1/artifact/{artifactHrn}/**"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    if (params["authorizationClaims"] !== undefined)
        headers["authorization-claims"] = params["authorizationClaims"] as string;

    return builder.request<any>(urlBuilder, options);
}

/**
 * Requires permission to 'apiAccess'
 *
 * @summary Register a new group and artifact
 * @param groupId groupId
 * @param artifactId artifactId
 * @param authorizationClaims authorization-claims
 * @param registerRequest registerRequest
 */
export function registerArtifactUsingPUT(builder: RequestBuilder, params: {  groupId: string; artifactId: string; authorizationClaims?: string; registerRequest?: RegisterArtifactRequest; }): Promise<RegisterArtifactResponse> {
    const baseUrl = "/v1/artifact/register/{groupId}/{artifactId}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{artifactId}", UrlBuilder.toString(params["artifactId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["registerRequest"] !== undefined)
        options.body = JSON.stringify(params["registerRequest"]);
    if (params["authorizationClaims"] !== undefined)
        headers["authorization-claims"] = params["authorizationClaims"] as string;

    return builder.request<RegisterArtifactResponse>(urlBuilder, options);
}

/* ===================================================================
 * SchemasApi
*/


/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete schema
 * @param schemaHrn schemaHrn
 */
export function deleteSchemaUsingDELETE(builder: RequestBuilder, params: {  schemaHrn: string; }): Promise<DeleteSchemaResponse> {
    const baseUrl = "/v1/schema/{schemaHrn}"
        .replace("{schemaHrn}", UrlBuilder.toString(params["schemaHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteSchemaResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Resolve a schema doc variant URL
 * @param schemaHrn schemaHrn
 * @param file file
 */
export function getDocumentUsingGET(builder: RequestBuilder, params: {  schemaHrn: string; file: string; }): Promise<InputStream> {
    const baseUrl = "/v1/schema/{schemaHrn}/doc/{file}"
        .replace("{schemaHrn}", UrlBuilder.toString(params["schemaHrn"]))
        .replace("{file}", UrlBuilder.toString(params["file"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<InputStream>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Retrieve schema details
 * @param schemaHrn schemaHrn
 */
export function getSchemaUsingGET(builder: RequestBuilder, params: {  schemaHrn: string; }): Promise<GetSchemaResponse> {
    const baseUrl = "/v1/schema/{schemaHrn}"
        .replace("{schemaHrn}", UrlBuilder.toString(params["schemaHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GetSchemaResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'apiAccess'
 *
 * @summary List the available schemas
 * @param sort 
 * @param order 
 * @param from 
 * @param limit 
 */
export function listUsingGET(builder: RequestBuilder, params: {  sort?: string; order?: string; from?: string; limit?: number; }): Promise<ListSchemasResponse> {
    const baseUrl = "/v1/schema";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("sort", params["sort"]);
    urlBuilder.appendQuery("order", params["order"]);
    urlBuilder.appendQuery("from", params["from"]);
    urlBuilder.appendQuery("limit", params["limit"]);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ListSchemasResponse>(urlBuilder, options);
}

/**
 * READ grants 'readResource', MODIFY grants 'modifyResource', SHARE grants 'shareResource'.  Requires permission to 'shareResource' for the given HRN.
 *
 * @summary Update schema permissions for user on the specified schema and associated artifact.
 * @param schemaHrn schemaHrn
 * @param updatePermissionRequest updatePermissionRequest
 */
export function updateSchemaPermissionUsingPOST(builder: RequestBuilder, params: {  schemaHrn: string; updatePermissionRequest?: UpdatePermissionRequest; }): Promise<UpdatePermissionResponse> {
    const baseUrl = "/v1/schema/{schemaHrn}/permission"
        .replace("{schemaHrn}", UrlBuilder.toString(params["schemaHrn"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string; } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["updatePermissionRequest"] !== undefined)
        options.body = JSON.stringify(params["updatePermissionRequest"]);

    return builder.request<UpdatePermissionResponse>(urlBuilder, options);
}
